### ğŸ“‚ Project File Tree

ğŸ“‚ ./
    ğŸ“„ combined_output.txt
    ğŸ“„ package.json
    ğŸ“‚ client/
        ğŸ“„ index.html
        ğŸ“„ package.json
        ğŸ“‚ public/
            ğŸ“„ logo.ico
            ğŸ“„ vite.svg
        ğŸ“‚ src/
            ğŸ“„ App.css
            ğŸ“„ App.jsx
            ğŸ“„ index.css
            ğŸ“„ main.jsx
            ğŸ“‚ api/
                ğŸ“„ axios.js
            ğŸ“‚ assets/
                ğŸ“„ logo.png
                ğŸ“„ react.svg
                ğŸ“„ tzp-1.png
                ğŸ“„ tzp-2.png
            ğŸ“‚ components/
                ğŸ“„ AuthLayout.jsx
                ğŸ“„ BookmarkCard.jsx
                ğŸ“„ Header.jsx
                ğŸ“„ MovieCard.jsx
                ğŸ“„ MovieCarousel.jsx
                ğŸ“„ ProtectedRoute.jsx
                ğŸ“„ ThemeToggle.jsx
                ğŸ“„ UserPageLayout.jsx
                ğŸ“‚ admin/
                    ğŸ“„ SuggestionCard.jsx
                    ğŸ“„ SuggestionReviewPanel.jsx
                    ğŸ“„ UserManagementPanel.jsx
                ğŸ“‚ movie-observations/
                    ğŸ“„ AnalysisFeed.jsx
                    ğŸ“„ ContentTabs.jsx
                    ğŸ“„ FilterBar.jsx
                    ğŸ“„ MovieHeader.jsx
                    ğŸ“„ ObservationFeed.jsx
                    ğŸ“„ QuickStats.jsx
                    ğŸ“„ SceneDetail.jsx
                    ğŸ“„ SceneFrame.jsx
                    ğŸ“„ SceneListSidebar.jsx
                    ğŸ“‚ modals/
                        ğŸ“„ ManageScenesModal.jsx
                        ğŸ“„ NewObservationModal.jsx
                        ğŸ“„ SuggestionModal.jsx
                        ğŸ“„ UploadAnalysisModal.jsx
                    ğŸ“‚ posts/
                        ğŸ“„ AnalysisPost.jsx
                        ğŸ“„ ObservationPost.jsx
            ğŸ“‚ context/
                ğŸ“„ AuthContext.jsx
                ğŸ“„ ThemeContext.jsx
            ğŸ“‚ hooks/
                ğŸ“„ useMovieData.js
                ğŸ“„ useMovies.js
            ğŸ“‚ pages/
                ğŸ“„ AdminDashboard.jsx
                ğŸ“„ AdminLogin.jsx
                ğŸ“„ AdminRegister.jsx
                ğŸ“„ AuthForms.jsx
                ğŸ“„ BookmarksPage.jsx
                ğŸ“„ ContributorDashboard.jsx
                ğŸ“„ Home.jsx
                ğŸ“„ MovieObservationsPage.jsx
                ğŸ“„ ObserverLogin.jsx
                ğŸ“„ ObserverRegister.jsx
                ğŸ“„ SearchResultsPage.jsx
                ğŸ“„ SettingsPage.jsx
                ğŸ“„ VerifyEmailPage.jsx
                ğŸ“„ ViewingHistoryPage.jsx
    ğŸ“‚ server/
        ğŸ“„ package.json
        ğŸ“‚ src/
            ğŸ“„ index.js
            ğŸ“‚ config/
                ğŸ“„ db.js
                ğŸ“„ mailer.js
            ğŸ“‚ controllers/
                ğŸ“„ adminController.js
                ğŸ“„ analysisContoller.js
                ğŸ“„ authController.js
                ğŸ“„ movieController.js
                ğŸ“„ observationController.js
                ğŸ“„ sceneController.js
                ğŸ“„ suggestionController.js
                ğŸ“„ userController.js
            ğŸ“‚ middleware/
                ğŸ“„ authMiddleware.js
                ğŸ“„ uploadMiddleware.js
            ğŸ“‚ models/
                ğŸ“„ Analysis.js
                ğŸ“„ Movie.js
                ğŸ“„ Observation.js
                ğŸ“„ Scene.js
                ğŸ“„ Suggestion.js
                ğŸ“„ User.js
            ğŸ“‚ routes/
                ğŸ“„ adminRoutes.js
                ğŸ“„ analysisRoutes.js
                ğŸ“„ authRoutes.js
                ğŸ“„ movieRoutes.js
                ğŸ“„ observationRoutes.js
                ğŸ“„ sceneRoutes.js
                ğŸ“„ suggestionRoutes.js
                ğŸ“„ userRoutes.js

----------------------------------------

### ğŸ“ File Contents

<package.json>

{
  "devDependencies": {
    "concurrently": "^9.2.1",
    "wait-on": "^9.0.1"
  },
  "name": "prism-film-observatory",
  "version": "1.0.0",
  "description": "A community platform to explore, discuss, and analyze films scene by scene.",
  "main": "index.js",
  "dependencies": {
    "ansi-regex": "^5.0.1",
    "ansi-styles": "^4.3.0",
    "chalk": "^4.1.2",
    "cliui": "^8.0.1",
    "color-convert": "^2.0.1",
    "color-name": "^1.1.4",
    "emoji-regex": "^8.0.0",
    "escalade": "^3.2.0",
    "get-caller-file": "^2.0.5",
    "has-flag": "^4.0.0",
    "is-fullwidth-code-point": "^3.0.0",
    "require-directory": "^2.1.1",
    "rxjs": "^7.8.2",
    "shell-quote": "^1.8.3",
    "string-width": "^4.2.3",
    "strip-ansi": "^6.0.1",
    "supports-color": "^8.1.1",
    "tree-kill": "^1.2.2",
    "tslib": "^2.8.1",
    "wrap-ansi": "^7.0.0",
    "y18n": "^5.0.8",
    "yargs": "^17.7.2",
    "yargs-parser": "^21.1.1"
  },
  "scripts": {
    "start:backend": "npm run dev --prefix server",
    "start:frontend": "npm run dev --prefix client",
    "dev": "concurrently \"npm run start:backend\" \"wait-on http://localhost:5000 && npm run start:frontend\""
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/shantanuk7/prism-film-observatory.git"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/shantanuk7/prism-film-observatory/issues"
  },
  "homepage": "https://github.com/shantanuk7/prism-film-observatory#readme"
}


---

<client\index.html>

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/logo.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Prism Film Observatory | Deconstruct Your Favorite Films</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>


---

<client\package.json>

{
  "name": "client",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@tailwindcss/vite": "^4.1.12",
    "axios": "^1.11.0",
    "date-fns": "^4.1.0",
    "lucide-react": "^0.542.0",
    "react": "^19.1.1",
    "react-dom": "^19.1.1",
    "react-router-dom": "^7.8.2",
    "tailwind-scrollbar-hide": "^4.0.0",
    "tailwindcss": "^4.1.12"
  },
  "devDependencies": {
    "@eslint/js": "^9.33.0",
    "@types/react": "^19.1.10",
    "@types/react-dom": "^19.1.7",
    "@vitejs/plugin-react": "^5.0.0",
    "eslint": "^9.33.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.20",
    "globals": "^16.3.0",
    "vite": "^7.1.2"
  }
}


---

<client\src\App.css>



---

<client\src\App.jsx>

import { BrowserRouter, Routes, Route } from 'react-router-dom';
import ProtectedRoute from './components/ProtectedRoute';

// Pages
import Home from './pages/Home';
import ObserverLogin from './pages/ObserverLogin';
import ObserverRegister from './pages/ObserverRegister';
import AdminLogin from './pages/AdminLogin';
import AdminRegister from './pages/AdminRegister';
import MovieObservationsPage from './pages/MovieObservationsPage';
import SearchResultsPage from './pages/SearchResultsPage';
import AdminDashboard from './pages/AdminDashboard';
import BookmarksPage from './pages/BookmarksPage';
import ViewingHistoryPage from './pages/ViewingHistoryPage';
import SettingsPage from './pages/SettingsPage';
import VerifyEmailPage from './pages/VerifyEmailPage';

export default function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/search" element={<SearchResultsPage />} />
        
        {/* Simplified Movie Route */}
        <Route path="/movie/:id" element={<MovieObservationsPage />} />

        {/* Auth Routes */}
        <Route path="/observer/login" element={<ObserverLogin />} />
        <Route path="/observer/register" element={<ObserverRegister />} />
        <Route path="/admin/login" element={<AdminLogin />} />
        <Route path="/admin/register" element={<AdminRegister />} />

        <Route path="/verify-email" element={<VerifyEmailPage />} />

        {/* -- Observer Protected Route -- */}
        <Route path="/bookmarks" element={<ProtectedRoute><BookmarksPage /></ProtectedRoute>} />
        <Route path="/history" element={<ProtectedRoute><ViewingHistoryPage /></ProtectedRoute>} />
        <Route path="/settings" element={<ProtectedRoute><SettingsPage /></ProtectedRoute>} />

        {/* -- Admin Protected Route -- */}
        <Route 
          path="/admin/dashboard"
          element={
            <ProtectedRoute role="admin">
              <AdminDashboard />
            </ProtectedRoute>
          }
        />
      </Routes>
    </BrowserRouter>
  )
}

---

<client\src\index.css>

@import "tailwindcss";
@import 'tailwind-scrollbar-hide/v4';
@custom-variant dark (&:where([data-theme=dark], [data-theme=dark] *));

@layer base {
  body {
    /* Default light mode styles */
    @apply bg-gray-100 text-gray-900 transition-colors duration-300;
  }

  /* When data-theme="dark" is on the <html> tag, these styles apply to the body */
  [data-theme="dark"] body {
    @apply bg-slate-900 text-slate-200;
  }
}

* {
  box-sizing: border-box;
}


---

<client\src\main.jsx>

import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.jsx'
import './index.css'
import { AuthProvider } from './context/AuthContext.jsx'
import { ThemeProvider } from './context/ThemeContext.jsx'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <AuthProvider>
      <ThemeProvider>
        <App />
      </ThemeProvider>
    </AuthProvider>
  </React.StrictMode>,
)


---

<client\src\api\axios.js>

import axios from 'axios'

const instance = axios.create({
  baseURL: import.meta.env.VITE_BASE_URL,
  withCredentials: true
})

export default instance

---

<client\src\components\AuthLayout.jsx>

// client/src/components/AuthLayout.jsx
import React from 'react';
import { Link } from 'react-router-dom';

const prismLogo = '/src/assets/logo.png'; // Make sure this path is correct

const AuthLayout = ({ children }) => {
    return (
        <div className="flex flex-col items-center justify-center min-h-screen bg-gray-100 dark:bg-slate-900 p-4">
            <div className="absolute top-0 left-0 w-full h-full bg-gradient-to-br from-teal-500/20 via-transparent to-transparent dark:from-teal-900/30"></div>
            <div className="z-10 text-center mb-8">
                <Link to="/" className="inline-flex items-center gap-3">
                    <img src={prismLogo} alt="Prism Logo" className="w-12 h-12" />
                    <h1 className="text-3xl font-bold text-gray-800 dark:text-slate-100">Prism</h1>
                </Link>
            </div>
            <div className="z-10 w-full max-w-md">
                {children}
            </div>
        </div>
    );
};

export default AuthLayout;

---

<client\src\components\BookmarkCard.jsx>

import React from 'react';
import { Link } from 'react-router-dom';
import { Film } from 'lucide-react';

const tmdbImageBaseUrl = 'https://image.tmdb.org/t/p/w500';

const BookmarkCard = ({ bookmark, movie }) => {
  // 'bookmark' can be either an Observation or an Analysis object
  const isObservation = bookmark.content;

  return (
    <div className="bg-white dark:bg-slate-800 rounded-lg shadow-sm border dark:border-slate-700 overflow-hidden flex transition-shadow hover:shadow-md">
      {/* Movie Poster */}
      <Link to={`/movie/${bookmark.movieId}`} className="flex-shrink-0 w-24">
        {movie.poster_path ? (
          <img src={`${tmdbImageBaseUrl}${movie.poster_path}`} alt={movie.title} className="w-full h-full object-cover" />
        ) : (
          <div className="w-full h-full flex items-center justify-center bg-gray-100 dark:bg-slate-700">
            <Film className="text-gray-400 dark:text-slate-500" size={32} />
          </div>
        )}
      </Link>
      
      {/* Bookmark Details */}
      <div className="p-4 flex flex-col justify-between flex-grow">
        <div>
          <p className="text-xs text-gray-500 dark:text-slate-400">
            {isObservation ? 'OBSERVATION FROM' : 'ANALYSIS FOR'}
          </p>
          <h3 className="font-bold text-gray-900 dark:text-slate-100 mb-1">{movie.title}</h3>
          <p className="text-sm text-gray-700 dark:text-slate-300 italic line-clamp-2">
            "{isObservation ? bookmark.content : bookmark.title}"
          </p>
        </div>
        <div className="mt-4 flex justify-between items-center">
          <p className="text-xs text-gray-500 dark:text-slate-400">
            By {bookmark.user?.username || 'user'}
          </p>
          <Link to={`/movie/${bookmark.movieId}`} className="text-sm font-semibold text-teal-600 dark:text-teal-400 hover:underline">
            View Post &rarr;
          </Link>
        </div>
      </div>
    </div>
  );
};

export default BookmarkCard;

---

<client\src\components\Header.jsx>

import React, { useState, useEffect, useRef } from 'react';
import { NavLink, Link, useLocation, useNavigate } from 'react-router-dom';
import { Search, Bookmark, History } from 'lucide-react';
import { useAuth } from '../context/AuthContext';
import ThemeToggle from './ThemeToggle';

const prismLogo = '../src/assets/logo.png';

export default function Header() {
  const { user, logout, loading } = useAuth();
  const [isUserMenuOpen, setIsUserMenuOpen] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  
  const location = useLocation();
  const navigate = useNavigate();
  const menuRef = useRef(null);

  useEffect(() => {
    const handleClickOutside = (event) => {
      if (menuRef.current && !menuRef.current.contains(event.target)) {
        setIsUserMenuOpen(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  const handleSearchSubmit = (e) => {
    e.preventDefault();
    if (searchQuery.trim()) {
      navigate(`/search?query=${encodeURIComponent(searchQuery)}`);
    }
  };
  
  const handleLogout = async () => {
    await logout();
    setIsUserMenuOpen(false);
    navigate('/');
  }

  const searchPlaceholder = location.pathname.includes('/movie/')
    ? 'Search observations & analyses...'
    : 'Search all movies...';

  const navLinkClasses = "flex items-center gap-2 px-3 py-2 rounded-md text-sm font-medium transition-colors text-gray-600 dark:text-slate-300 hover:bg-gray-100 dark:hover:bg-slate-800";
  const activeNavLinkClasses = "bg-gray-100 dark:bg-slate-800 text-teal-600 dark:text-white";

  return (
    <header className="bg-white dark:bg-slate-900 border-b border-gray-200 dark:border-slate-800 fixed top-0 left-0 w-full z-30 h-16 flex items-center px-4 sm:px-6">
      <div className="flex items-center gap-4 w-full">
        <Link to="/" className="flex items-center gap-3 flex-shrink-0">
          <img src={prismLogo} alt="Prism Logo" className="w-8 h-8" />
          <span className="text-lg font-bold text-gray-900 dark:text-slate-100 hidden md:block">Prism</span>
        </Link>

        <form onSubmit={handleSearchSubmit} className="relative flex-1 max-w-lg mx-auto">
          <Search size={18} className="absolute left-3.5 top-1/2 -translate-y-1/2 text-gray-400 dark:text-slate-500" />
          <input type="search" value={searchQuery} onChange={(e) => setSearchQuery(e.target.value)} placeholder={searchPlaceholder} className="w-full bg-gray-100 dark:bg-slate-800 border border-transparent dark:text-slate-200 rounded-lg pl-10 pr-4 py-2 text-sm placeholder-gray-500 dark:placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-teal-500 dark:focus:bg-slate-700 transition" />
        </form>

        <div className="flex items-center gap-2 sm:gap-4">
          {!loading && (
            <>
              {user ? (
                <>
                  <nav className="hidden md:flex items-center gap-2">
                    <NavLink to="/bookmarks" className={({ isActive }) => `${navLinkClasses} ${isActive ? activeNavLinkClasses : ''}`}>
                        <Bookmark size={16} /> Bookmarks
                    </NavLink>
                    <NavLink to="/history" className={({ isActive }) => `${navLinkClasses} ${isActive ? activeNavLinkClasses : ''}`}>
                        <History size={16} /> History
                    </NavLink>
                  </nav>
                  
                  <ThemeToggle />
                  <div className="relative" ref={menuRef}>
                    <button onClick={() => setIsUserMenuOpen(!isUserMenuOpen)} className="w-9 h-9 bg-gray-200 rounded-full focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-teal-500 dark:focus:ring-offset-slate-900 flex items-center justify-center overflow-hidden">
                      <img src={user.avatarUrl} alt="User Avatar" className="w-full h-full object-cover" />
                    </button>
                    {isUserMenuOpen && (
                      <div className="absolute top-full mt-2 right-0 w-56 bg-white dark:bg-slate-800 border border-gray-200 dark:border-slate-700 rounded-md shadow-lg py-1 z-20 animate-fade-in-up">
                        <div className="px-3 py-2 border-b dark:border-slate-700">
                          <p className="text-sm font-semibold text-gray-800 dark:text-slate-200 truncate">{user.username}</p>
                          <p className="text-xs text-gray-500 dark:text-slate-400 truncate">{user.email}</p>
                        </div>
                        <div className="py-1">
                          {user.role === 'admin' && (
                            <Link to="/admin/dashboard" onClick={() => setIsUserMenuOpen(false)} className="block w-full text-left px-3 py-2 text-sm font-medium text-teal-600 dark:text-teal-400 hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors">
                                Admin Dashboard
                            </Link>
                          )}
                          <Link to="/settings" onClick={() => setIsUserMenuOpen(false)} className="block w-full text-left px-3 py-2 text-sm text-gray-700 dark:text-slate-300 hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors">Settings</Link>
                          {/* Add links for mobile view */}
                          <Link to="/bookmarks" onClick={() => setIsUserMenuOpen(false)} className="md:hidden block w-full text-left px-3 py-2 text-sm text-gray-700 dark:text-slate-300 hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors">Bookmarks</Link>
                          <Link to="/history" onClick={() => setIsUserMenuOpen(false)} className="md:hidden block w-full text-left px-3 py-2 text-sm text-gray-700 dark:text-slate-300 hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors">History</Link>
                        </div>
                        <div className="my-1 h-px bg-gray-100 dark:bg-slate-700"></div>
                        <button onClick={handleLogout} className="w-full text-left px-3 py-2 text-sm text-red-600 dark:text-red-500 hover:bg-red-50 dark:hover:bg-red-500/10 transition-colors">Logout</button>
                      </div>
                    )}
                  </div>
                </>
              ) : (
                <>
                  <ThemeToggle />
                  <div className="flex items-center gap-2">
                    <button onClick={() => navigate('/observer/login')} className="px-4 py-2 text-sm font-medium text-gray-700 dark:text-slate-200 hover:bg-gray-100 dark:hover:bg-slate-800 rounded-md transition-colors">Log In</button>
                    <button onClick={() => navigate('/observer/register')} className="px-4 py-2 text-sm font-medium text-white bg-teal-600 rounded-md hover:bg-teal-700 transition-colors">Sign Up</button>
                  </div>
                </>
              )}
            </>
          )}
        </div>
      </div>
    </header>
  );
}

---

<client\src\components\MovieCard.jsx>

import { Link } from 'react-router-dom'
import { Film } from 'lucide-react'

const tmdbImageBaseUrl = 'https://image.tmdb.org/t/p/w500'

export default function MovieCard({ movie }) {
  return (
    <Link
      to={`/movie/${movie.id}`}
      className="block group flex-shrink-0 w-40 md:w-48"
    >
      <div className="aspect-[2/3] bg-gray-200 dark:bg-slate-800 rounded-lg overflow-hidden transition-transform transform group-hover:scale-105 group-hover:shadow-xl">
        {movie.poster_path ? (
          <img
            src={`${tmdbImageBaseUrl}${movie.poster_path}`}
            alt={movie.title}
            className="w-full h-full object-cover"
          />
        ) : (
          <div className="w-full h-full flex items-center justify-center text-gray-400 dark:text-slate-500 bg-gray-100 dark:bg-slate-700">
            <Film size={48} />
          </div>
        )}
      </div>
      <h3 className="mt-2 text-sm font-medium text-gray-800 dark:text-slate-200 truncate group-hover:text-teal-600 dark:group-hover:text-teal-400">
        {movie.title}
      </h3>
    </Link>
  )
}


---

<client\src\components\MovieCarousel.jsx>

import { Link } from 'react-router-dom'
import { ArrowRight, Loader2 } from 'lucide-react'
import MovieCard from './MovieCard'

export default function MovieCarousel({ title, movies, isLoading }) {
  if (isLoading) {
    return (
      <section className="mb-12">
        <h2 className="text-xl md:text-2xl font-bold text-gray-900 dark:text-slate-100 mb-4">{title}</h2>
        <div className="flex justify-center items-center h-48">
          <Loader2 className="animate-spin text-teal-600" size={40} />
        </div>
      </section>
    )
  }

  if (!movies || movies.length === 0) return null

  return (
    <section className="mb-12">
      <div className="flex items-center justify-between mb-4">
        <h2 className="text-xl md:text-2xl font-bold text-gray-900 dark:text-slate-100">{title}</h2>
        <Link
          to={`/movies/category/${title.toLowerCase().replace(' ', '-')}`}
          className="flex items-center gap-1 text-sm font-medium text-teal-600 hover:text-teal-800 dark:text-teal-400 dark:hover:text-teal-300"
        >
          See All <ArrowRight size={14} />
        </Link>
      </div>
      <div className="flex gap-4 md:gap-6 overflow-x-auto pb-4 -mx-6 px-6">
        {movies.map((movie) => (
          <MovieCard key={movie.id} movie={movie} />
        ))}
      </div>
    </section>
  )
}


---

<client\src\components\ProtectedRoute.jsx>

import { Navigate } from 'react-router-dom'
import { useAuth } from '../context/AuthContext'
import { Loader2 } from 'lucide-react';

export default function ProtectedRoute({ children, role }) {
  const { user, loading } = useAuth();

  if (loading) {
    return (
        <div className="flex justify-center items-center h-screen">
            {/* The spinner will now use a slightly brighter teal in dark mode for better visibility */}
            <Loader2 className="animate-spin text-teal-600 dark:text-teal-500" size={48} />
        </div>
    );
  }

  // If not logged in, redirect to the login page.
  if (!user) {
    return <Navigate to="/observer/login" />;
  }

  // If a role is required and the user's role doesn't match, redirect to the home page.
  if (role && user.role !== role) {
    return <Navigate to="/" />;
  }
  
  return children;
}


---

<client\src\components\ThemeToggle.jsx>

import React from 'react';
import { Sun, Moon } from 'lucide-react';
import { useTheme } from '../context/ThemeContext';

export default function ThemeToggle() {
    const { theme, toggleTheme } = useTheme();

    return (
        <button
            onClick={toggleTheme}
            className="w-9 h-9 bg-gray-200 dark:bg-slate-800 rounded-full flex items-center justify-center focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-teal-500 dark:focus:ring-offset-slate-900"
            aria-label="Toggle theme"
        >
            {theme === 'light' ? (
                <Moon size={18} className="text-gray-700" />
            ) : (
                <Sun size={18} className="text-yellow-400" />
            )}
        </button>
    );
}


---

<client\src\components\UserPageLayout.jsx>

// client/src/components/UserPageLayout.jsx

import React from 'react';
import Header from './Header';

const UserPageLayout = ({ title, icon, children }) => {
    // The Icon component is passed as a prop, so we render it directly.
    const IconComponent = icon; 

    return (
        <div className="bg-white dark:bg-slate-900 min-h-screen transition-colors">
            <Header />
            <main className="container mx-auto px-4 sm:px-6 lg:px-8 pt-24 pb-12">
                <div className="max-w-6xl mx-auto">
                    {/* Page Header */}
                    <div className="flex items-center gap-3 mb-6 pb-5 border-b border-gray-200 dark:border-slate-700">
                        {IconComponent && <IconComponent className="text-teal-600 dark:text-teal-400" size={28} />}
                        <h1 className="text-2xl font-bold text-gray-900 dark:text-slate-100">{title}</h1>
                    </div>
                    {/* Page Content */}
                    <div>
                        {children}
                    </div>
                </div>
            </main>
        </div>
    );
};

export default UserPageLayout;

---

<client\src\components\admin\SuggestionCard.jsx>

import React, { useState } from 'react';
import axios from '../../api/axios';
import { Check, X, Clock, User, Shield } from 'lucide-react';
import { formatDistanceToNow } from 'date-fns';

// A small component to show differences clearly
const DiffField = ({ label, original, suggested }) => {
    // Don't show if there's no change and it's not a new scene
    if (original === suggested && original !== undefined) return null; 
    
    return (
        <div className="text-sm mb-2">
            <strong className="font-medium text-gray-700 dark:text-slate-300 block">{label}</strong>
            {original && <p className="text-red-600 dark:text-red-500 line-through opacity-70"> - {original}</p>}
            <p className="text-green-600 dark:text-green-500"> + {suggested || "Not provided"}</p>
        </div>
    );
};

export default function SuggestionCard({ suggestion, onUpdate }) {
    const [loading, setLoading] = useState(false);
    
    const handleAction = async (action) => {
        setLoading(true);
        try {
            await axios.put(`/admin/suggestions/${suggestion._id}/${action}`);
            onUpdate(suggestion._id); // Notify parent to remove this card
        } catch (error) {
            console.error(`Failed to ${action} suggestion`, error);
            alert(`Could not ${action} the suggestion.`);
            setLoading(false); // Reset loading state only on error
        }
    };
    
    const { payload, sceneToEdit, suggestionType, suggestedBy } = suggestion;

    return (
        <div className="bg-white dark:bg-slate-800 border dark:border-slate-700 rounded-lg shadow-sm transition-shadow hover:shadow-md">
            {/* Card Header */}
            <div className="p-4 border-b dark:border-slate-700 flex flex-col sm:flex-row justify-between sm:items-center gap-2">
                <div>
                    <span className={`text-xs font-bold py-1 px-2 rounded-full ${suggestionType === 'NEW_SCENE' ? 'bg-blue-100 text-blue-800 dark:bg-blue-900/40 dark:text-blue-300' : 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/40 dark:text-yellow-300'}`}>
                        {suggestionType.replace('_', ' ')}
                    </span>
                    <p className="text-lg font-bold mt-2 text-gray-900 dark:text-slate-100">
                        {suggestionType === 'NEW_SCENE' ? `New Scene Suggestion` : `Edit for Scene ${sceneToEdit?.sceneNumber}`}
                        <span className="text-base font-medium text-gray-500 dark:text-slate-400"> for Movie ID: {suggestion.movieId}</span>
                    </p>
                </div>
                <div className="text-left sm:text-right text-sm text-gray-500 dark:text-slate-400">
                    <div className="flex items-center gap-2">
                        <img src={suggestedBy.avatarUrl} alt="Suggester's avatar" className="w-6 h-6 rounded-full"/>
                        <p>{suggestedBy.username}</p>
                    </div>
                    <p className="flex items-center gap-1 justify-start sm:justify-end mt-1"><Clock size={12}/>{formatDistanceToNow(new Date(suggestion.createdAt), { addSuffix: true })}</p>
                </div>
            </div>
            
            <div className="p-4 grid grid-cols-1 md:grid-cols-2 gap-6">
                {/* Details Section */}
                <div className="space-y-3">
                    <h4 className="font-semibold text-gray-800 dark:text-slate-200 border-b dark:border-slate-600 pb-1">Suggested Details</h4>
                    <DiffField label="Description" original={sceneToEdit?.description} suggested={payload.description} />
                    <DiffField label="Start Time" original={sceneToEdit?.startTime} suggested={payload.startTime} />
                    <DiffField label="End Time" original={sceneToEdit?.endTime} suggested={payload.endTime} />
                </div>
                
                {/* Frames Section */}
                <div className="space-y-2">
                     <h4 className="font-semibold text-gray-800 dark:text-slate-200 border-b dark:border-slate-600 pb-1">Frame Comparison</h4>
                     <div className="grid grid-cols-2 gap-2">
                        {suggestionType === 'EDIT_SCENE' && (
                            <div>
                                <p className="text-xs font-medium text-gray-500 dark:text-slate-400">ORIGINAL START</p>
                                <img src={sceneToEdit?.startFrameUrl} alt="Original Start" className="w-full rounded object-cover aspect-video bg-gray-200 dark:bg-slate-700 mt-1"/>
                            </div>
                        )}
                         <div>
                            <p className="text-xs font-medium text-green-600 dark:text-green-400">SUGGESTED START</p>
                            <img src={payload.startFrameUrl} alt="Suggested Start" className="w-full rounded object-cover aspect-video bg-gray-200 dark:bg-slate-700 mt-1"/>
                        </div>
                        {suggestionType === 'EDIT_SCENE' && (
                            <div>
                                <p className="text-xs font-medium text-gray-500 dark:text-slate-400">ORIGINAL END</p>
                                <img src={sceneToEdit?.endFrameUrl} alt="Original End" className="w-full rounded object-cover aspect-video bg-gray-200 dark:bg-slate-700 mt-1"/>
                            </div>
                        )}
                         <div>
                            <p className="text-xs font-medium text-green-600 dark:text-green-400">SUGGESTED END</p>
                            <img src={payload.endFrameUrl} alt="Suggested End" className="w-full rounded object-cover aspect-video bg-gray-200 dark:bg-slate-700 mt-1"/>
                        </div>
                     </div>
                </div>
            </div>
            
            {/* Actions Footer */}
            <div className="p-4 bg-gray-50 dark:bg-slate-800/50 flex justify-end gap-3 rounded-b-lg">
                <button onClick={() => handleAction('reject')} disabled={loading} className="flex items-center gap-2 px-4 py-2 bg-red-600 text-white rounded-md text-sm font-medium hover:bg-red-700 disabled:opacity-50 disabled:cursor-not-allowed">
                    <X size={16} /> Reject
                </button>
                <button onClick={() => handleAction('approve')} disabled={loading} className="flex items-center gap-2 px-4 py-2 bg-green-600 text-white rounded-md text-sm font-medium hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">
                    <Check size={16} /> Approve
                </button>
            </div>
        </div>
    );
}

---

<client\src\components\admin\SuggestionReviewPanel.jsx>

import React, { useState, useEffect } from 'react';
import axios from '../../api/axios';
import SuggestionCard from './SuggestionCard';
import { Loader2 } from 'lucide-react';

export default function SuggestionReviewPanel() {
    const [suggestions, setSuggestions] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState('');

    useEffect(() => {
        const fetchSuggestions = async () => {
            try {
                setLoading(true);
                const { data } = await axios.get('/admin/suggestions');
                setSuggestions(data);
            } catch (err) {
                setError('Failed to load suggestions.');
                console.error(err);
            } finally {
                setLoading(false);
            }
        };
        fetchSuggestions();
    }, []);

    const handleUpdateSuggestion = (suggestionId) => {
        setSuggestions(prev => prev.filter(s => s._id !== suggestionId));
    };

    if (loading) {
        return <div className="flex justify-center items-center h-64"><Loader2 className="animate-spin text-teal-500" size={48} /></div>;
    }
    if (error) {
        return <p className="text-center text-red-500">{error}</p>;
    }
    if (suggestions.length === 0) {
        return <p className="text-center text-gray-500 dark:text-slate-400 py-12">No pending suggestions. All caught up!</p>;
    }
    return (
        <div className="space-y-6">
            {suggestions.map(suggestion => (
                <SuggestionCard 
                    key={suggestion._id} 
                    suggestion={suggestion}
                    onUpdate={handleUpdateSuggestion}
                />
            ))}
        </div>
    );
}

---

<client\src\components\admin\UserManagementPanel.jsx>

import React, { useState, useEffect } from 'react';
import axios from '../../api/axios';
import { Loader2, Shield, User, MoreVertical, Trash2 } from 'lucide-react';
import { useAuth } from '../../context/AuthContext';

export default function UserManagementPanel() {
    const { user: currentUser } = useAuth();
    const [users, setUsers] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState('');
    const [activeMenu, setActiveMenu] = useState(null); // To control which user's menu is open

    const fetchUsers = async () => {
        try {
            setLoading(true);
            const { data } = await axios.get('/admin/users');
            setUsers(data);
        } catch (err) {
            setError('Failed to load users.');
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        fetchUsers();
    }, []);

    const handleRoleChange = async (userId, role) => {
        try {
            await axios.put(`/admin/users/${userId}/role`, { role });
            setUsers(users.map(u => u._id === userId ? { ...u, role } : u));
            setActiveMenu(null);
        } catch (err) {
            alert(err.response?.data?.message || 'Failed to update role.');
        }
    };

    const handleDeleteUser = async (userId) => {
        if (window.confirm('Are you sure you want to permanently delete this user?')) {
            try {
                await axios.delete(`/admin/users/${userId}`);
                setUsers(users.filter(u => u._id !== userId));
                setActiveMenu(null);
            } catch (err) {
                alert(err.response?.data?.message || 'Failed to delete user.');
            }
        }
    };
    
    if (loading) return <div className="flex justify-center items-center h-64"><Loader2 className="animate-spin text-teal-500" size={32} /></div>;
    if (error) return <p className="text-center text-red-500">{error}</p>;

    return (
        <div className="bg-white dark:bg-slate-800 border dark:border-slate-700 rounded-lg overflow-hidden">
            <table className="min-w-full divide-y divide-gray-200 dark:divide-slate-700">
                <thead className="bg-gray-50 dark:bg-slate-800">
                    <tr>
                        <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">User</th>
                        <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Role</th>
                        <th scope="col" className="relative px-6 py-3"><span className="sr-only">Actions</span></th>
                    </tr>
                </thead>
                <tbody className="bg-white dark:bg-slate-800 divide-y divide-gray-200 dark:divide-slate-700">
                    {users.map((user) => (
                        <tr key={user._id}>
                            <td className="px-6 py-4 whitespace-nowrap">
                                <div className="flex items-center">
                                    <div className="flex-shrink-0 h-10 w-10">
                                        <img className="h-10 w-10 rounded-full object-cover" src={user.avatarUrl} alt="" />
                                    </div>
                                    <div className="ml-4">
                                        <div className="text-sm font-medium text-gray-900 dark:text-slate-200">{user.username}</div>
                                        <div className="text-sm text-gray-500 dark:text-slate-400">{user.email}</div>
                                    </div>
                                </div>
                            </td>
                            <td className="px-6 py-4 whitespace-nowrap">
                                {user.role === 'admin' 
                                    ? <span className="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-teal-100 text-teal-800 dark:bg-teal-900/50 dark:text-teal-300">Admin</span>
                                    : <span className="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-gray-100 text-gray-800 dark:bg-slate-700 dark:text-slate-300">Observer</span>}
                            </td>
                            <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                                <div className="relative inline-block text-left">
                                    <button onClick={() => setActiveMenu(activeMenu === user._id ? null : user._id)} className="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-slate-700">
                                        <MoreVertical size={16}/>
                                    </button>
                                    {activeMenu === user._id && (
                                        <div className="origin-top-right absolute right-0 mt-2 w-48 rounded-md shadow-lg bg-white dark:bg-slate-900 ring-1 ring-black ring-opacity-5 z-10">
                                            <div className="py-1">
                                                {user.role === 'observer' ? (
                                                    <button onClick={() => handleRoleChange(user._id, 'admin')} className="w-full text-left flex items-center gap-3 px-4 py-2 text-sm text-gray-700 dark:text-slate-300 hover:bg-gray-100 dark:hover:bg-slate-800">
                                                        <Shield size={14}/> Make Admin
                                                    </button>
                                                ) : (
                                                    <button onClick={() => handleRoleChange(user._id, 'observer')} className="w-full text-left flex items-center gap-3 px-4 py-2 text-sm text-gray-700 dark:text-slate-300 hover:bg-gray-100 dark:hover:bg-slate-800">
                                                        <User size={14}/> Make Observer
                                                    </button>
                                                )}
                                                {currentUser._id !== user._id && (
                                                     <button onClick={() => handleDeleteUser(user._id)} className="w-full text-left flex items-center gap-3 px-4 py-2 text-sm text-red-600 dark:text-red-500 hover:bg-red-50 dark:hover:bg-red-500/10">
                                                        <Trash2 size={14}/> Delete User
                                                    </button>
                                                )}
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </td>
                        </tr>
                    ))}
                </tbody>
            </table>
        </div>
    );
}

---

<client\src\components\movie-observations\AnalysisFeed.jsx>

import React from 'react';
import { Link } from 'react-router-dom';
import AnalysisPost from './posts/AnalysisPost';
import FilterBar from './FilterBar';

const AnalysisFeed = ({ analyses, user, onLike, onBookmark, sort, setSort }) => {
    
  const renderFeed = () => {
    if (analyses.length === 0) {
      return (
        <div className="text-center text-gray-500 dark:text-slate-400 py-12">
          <p>No analysis has been uploaded for this movie yet.</p>
        </div>
      );
    }
    return (
      <div className="space-y-6">
        {analyses.map(anl => (
          <AnalysisPost key={anl._id} analysis={anl} user={user} onLike={onLike} onBookmark={onBookmark} />
        ))}
      </div>
    );
  };
    
  return (
    <div>
      <FilterBar
        sort={sort}
        setSort={setSort}
        type="analyses"
      />

      {renderFeed()}
      
      {!user && (
        <div className="mt-8 text-center bg-white dark:bg-slate-800 border border-teal-500/20 dark:border-teal-400/20 rounded-lg p-6">
          <h3 className="font-semibold text-gray-900 dark:text-white">Want to contribute?</h3>
          <p className="mt-1 text-sm text-gray-600 dark:text-slate-300">
            <Link to="/observer/login" className="text-teal-600 dark:text-teal-400 font-medium hover:underline">Log in</Link> or <Link to="/observer/register" className="text-teal-600 dark:text-teal-400 font-medium hover:underline">sign up</Link> to upload your own in-depth analysis.
          </p>
        </div>
      )}
    </div>
  );
};

export default AnalysisFeed;

---

<client\src\components\movie-observations\ContentTabs.jsx>

import React from 'react';
import { Film, FileText, Plus, Upload } from 'lucide-react';

const ContentTabs = ({ currentPage, onSetPage, user, authLoading, scenesExist, onNewObservationClick, onUploadAnalysisClick }) => {
    return (
        <div className="flex flex-wrap items-center justify-between gap-4 mb-6">
            <div className="flex items-center bg-gray-200 dark:bg-slate-800 p-1 rounded-lg">
                <button 
                    onClick={() => onSetPage("observations")} 
                    className={`px-4 py-1.5 text-sm font-semibold rounded-md transition-colors ${
                        currentPage === "observations" 
                        ? "bg-white dark:bg-slate-700 shadow-sm text-gray-900 dark:text-slate-100" 
                        : "text-gray-600 dark:text-slate-300 hover:text-gray-900 dark:hover:text-white"
                    }`}
                >
                    <Film size={16} className="inline mr-2"/>Observations
                </button>
                <button 
                    onClick={() => onSetPage("analysis")} 
                    className={`px-4 py-1.5 text-sm font-semibold rounded-md transition-colors ${
                        currentPage === "analysis" 
                        ? "bg-white dark:bg-slate-700 shadow-sm text-gray-900 dark:text-slate-100" 
                        : "text-gray-600 dark:text-slate-300 hover:text-gray-900 dark:hover:text-white"
                    }`}
                >
                    <FileText size={16} className="inline mr-2"/>Analysis
                </button>
            </div>
            {!authLoading && user && (
                <>
                    {currentPage === "observations" && scenesExist && (
                        <button onClick={onNewObservationClick} className="flex items-center gap-2 px-4 py-2 bg-teal-600 text-white rounded-md hover:bg-teal-700 text-sm font-medium">
                            <Plus size={16}/> New Observation
                        </button>
                    )}
                    {currentPage === "analysis" && (
                        <button onClick={onUploadAnalysisClick} className="flex items-center gap-2 px-4 py-2 bg-teal-600 text-white rounded-md hover:bg-teal-700 text-sm font-medium">
                            <Upload size={16}/> Upload Analysis
                        </button>
                    )}
                </>
            )}
        </div>
    );
};

export default ContentTabs;


---

<client\src\components\movie-observations\FilterBar.jsx>

import React, { useState, useRef, useEffect } from 'react';
import { Filter, ChevronDown, X, SortDesc } from 'lucide-react';

const FilterBar = ({ 
  activeCategory, 
  setActiveCategory, 
  sort, 
  setSort, 
  categories,
  type = "observations" // "observations" or "analyses"
}) => {
  const [showCategoryDropdown, setShowCategoryDropdown] = useState(false);
  const [showSortDropdown, setShowSortDropdown] = useState(false);
  const categoryDropdownRef = useRef(null);
  const sortDropdownRef = useRef(null);

  const sortOptions = type === "observations" 
    ? [
        { value: "newest", label: "Newest First" },
        { value: "oldest", label: "Oldest First" },
        { value: "mostLiked", label: "Most Liked" }
      ]
    : [
        { value: "newest", label: "Newest First" },
        { value: "oldest", label: "Oldest First" }
      ];

  // Close dropdowns when clicking outside
  useEffect(() => {
    const handleClickOutside = (event) => {
      if (categoryDropdownRef.current && !categoryDropdownRef.current.contains(event.target)) {
        setShowCategoryDropdown(false);
      }
      if (sortDropdownRef.current && !sortDropdownRef.current.contains(event.target)) {
        setShowSortDropdown(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  return (
    <div className="bg-white dark:bg-slate-800 border border-gray-200 dark:border-slate-700 rounded-lg p-4 mb-6">
      <div className="flex flex-col sm:flex-row gap-4 items-start sm:items-center justify-between">
        
        {/* Left side - Category Filter (only for observations) */}
        {type === "observations" && (
          <div className="flex items-center gap-3 flex-1 flex-wrap">
            <span className="text-sm font-medium text-gray-700 dark:text-slate-300 whitespace-nowrap">
              Filter by:
            </span>
            
            {/* Category Dropdown */}
            <div className="relative" ref={categoryDropdownRef}>
              <button
                onClick={() => setShowCategoryDropdown(!showCategoryDropdown)}
                className="flex items-center gap-2 px-4 py-2 bg-gray-100 dark:bg-slate-700 hover:bg-gray-200 dark:hover:bg-slate-600 rounded-lg transition-colors min-w-[140px]"
              >
                <Filter size={16} />
                <span className="text-sm truncate">
                  {activeCategory === 'All' ? 'All Categories' : activeCategory}
                </span>
                <ChevronDown size={16} className={`transition-transform ${showCategoryDropdown ? 'rotate-180' : ''}`} />
              </button>
              
              {showCategoryDropdown && (
                <div className="absolute top-full mt-2 left-0 w-64 bg-white dark:bg-slate-800 border border-gray-200 dark:border-slate-700 rounded-lg shadow-lg z-20 max-h-64 overflow-y-auto">
                  <div className="p-2">
                    <button
                      onClick={() => {
                        setActiveCategory('All');
                        setShowCategoryDropdown(false);
                      }}
                      className={`w-full text-left px-3 py-2 rounded-md text-sm transition-colors ${
                        activeCategory === 'All' 
                          ? 'bg-teal-100 dark:bg-teal-900/30 text-teal-700 dark:text-teal-300' 
                          : 'text-gray-700 dark:text-slate-300 hover:bg-gray-100 dark:hover:bg-slate-700'
                      }`}
                    >
                      All Categories
                    </button>
                    {categories.map(category => (
                      <button
                        key={category}
                        onClick={() => {
                          setActiveCategory(category);
                          setShowCategoryDropdown(false);
                        }}
                        className={`w-full text-left px-3 py-2 rounded-md text-sm transition-colors ${
                          activeCategory === category 
                            ? 'bg-teal-100 dark:bg-teal-900/30 text-teal-700 dark:text-teal-300' 
                            : 'text-gray-700 dark:text-slate-300 hover:bg-gray-100 dark:hover:bg-slate-700'
                        }`}
                      >
                        {category}
                      </button>
                    ))}
                  </div>
                </div>
              )}
            </div>

            {/* Active Filter Indicator */}
            {activeCategory !== 'All' && (
              <div className="flex items-center gap-2 px-3 py-1.5 bg-teal-100 dark:bg-teal-900/30 text-teal-700 dark:text-teal-300 rounded-full text-sm">
                <span className="truncate max-w-32">{activeCategory}</span>
                <button
                  onClick={() => setActiveCategory('All')}
                  className="hover:bg-teal-200 dark:hover:bg-teal-800 rounded-full p-0.5 flex-shrink-0"
                >
                  <X size={14} />
                </button>
              </div>
            )}
          </div>
        )}

        {/* Right side - Sort Options */}
        <div className="flex items-center gap-3">
          <span className="text-sm font-medium text-gray-700 dark:text-slate-300 whitespace-nowrap">
            Sort by:
          </span>
          
          <div className="relative" ref={sortDropdownRef}>
            <button
              onClick={() => setShowSortDropdown(!showSortDropdown)}
              className="flex items-center gap-2 px-4 py-2 bg-gray-100 dark:bg-slate-700 hover:bg-gray-200 dark:hover:bg-slate-600 rounded-lg transition-colors min-w-[130px]"
            >
              <SortDesc size={16} />
              <span className="text-sm">
                {sortOptions.find(opt => opt.value === sort)?.label}
              </span>
              <ChevronDown size={16} className={`transition-transform ${showSortDropdown ? 'rotate-180' : ''}`} />
            </button>
            
            {showSortDropdown && (
              <div className="absolute top-full mt-2 right-0 w-48 bg-white dark:bg-slate-800 border border-gray-200 dark:border-slate-700 rounded-lg shadow-lg z-20">
                <div className="p-2">
                  {sortOptions.map(option => (
                    <button
                      key={option.value}
                      onClick={() => {
                        setSort(option.value);
                        setShowSortDropdown(false);
                      }}
                      className={`w-full text-left px-3 py-2 rounded-md text-sm transition-colors ${
                        sort === option.value 
                          ? 'bg-teal-100 dark:bg-teal-900/30 text-teal-700 dark:text-teal-300' 
                          : 'text-gray-700 dark:text-slate-300 hover:bg-gray-100 dark:hover:bg-slate-700'
                      }`}
                    >
                      {option.label}
                    </button>
                  ))}
                </div>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
};

export default FilterBar;

---

<client\src\components\movie-observations\MovieHeader.jsx>

import { Info } from 'lucide-react';

const MovieHeader = ({ details }) => {
    if (!details) return null;

    const tmdbUrl = `https://www.themoviedb.org/movie/${details.id}`;

    return (
        <div className="mb-6">
            <div className="flex items-center gap-3">
                <h1 className="text-2xl font-bold text-gray-900 dark:text-slate-100">{details.title} ({details.release_date?.substring(0,4)})</h1>
                <a href={tmdbUrl} target="_blank" rel="noopener noreferrer" title="View on TMDB" className="text-teal-500 hover:text-teal-400">
                    <Info size={20} />
                </a>
            </div>
            <p className="text-sm text-gray-500 dark:text-slate-400">Runtime: {details.runtime} minutes</p>

            {details.timestampSource && (
                 <p className="text-xs text-gray-500 dark:text-slate-500 mt-2">
                    Timestamps based on the {details.timestampSource.url ? 
                        <a href={details.timestampSource.url} target="_blank" rel="noopener noreferrer" className="underline hover:text-teal-500">
                            {details.timestampSource.name}
                        </a> 
                        : details.timestampSource.name
                    }.
                </p>
            )}
        </div>
    );
};

export default MovieHeader;

---

<client\src\components\movie-observations\ObservationFeed.jsx>

import React from 'react';
import { Link } from 'react-router-dom';
import ObservationPost from './posts/ObservationPost';
import FilterBar from './FilterBar';
import QuickStats from './QuickStats';

const ObservationFeed = ({ 
  observations, 
  user, 
  onLike, 
  onBookmark, 
  categories, 
  activeCategory, 
  setActiveCategory, 
  sort, 
  setSort 
}) => {
  const renderFeed = () => {
    if (observations.length === 0) {
      return (
        <div className="text-center text-gray-500 dark:text-slate-400 py-12">
          <p>No observations for this scene yet. Be the first!</p>
        </div>
      );
    }
    return (
      <div className="space-y-4">
        {observations.map(obs => (
          <ObservationPost key={obs._id} observation={obs} user={user} onLike={onLike} onBookmark={onBookmark} />
        ))}
      </div>
    );
  };

  return (
    <div>
      <FilterBar
        activeCategory={activeCategory}
        setActiveCategory={setActiveCategory}
        sort={sort}
        setSort={setSort}
        categories={categories}
        type="observations"
      />

      <QuickStats 
        totalCount={categories.length > 0 ? observations.length : 0}
        filteredCount={observations.length}
        activeCategory={activeCategory}
        type="observations"
      />

      {renderFeed()}

      {!user && (
        <div className="mt-8 text-center bg-white dark:bg-slate-800 border border-teal-500/20 dark:border-teal-400/20 rounded-lg p-6">
          <h3 className="font-semibold text-gray-900 dark:text-white">Join the Discussion!</h3>
          <p className="mt-1 text-sm text-gray-600 dark:text-slate-300">
            <Link to="/observer/login" className="text-teal-600 dark:text-teal-400 font-medium hover:underline">Log in</Link> or <Link to="/observer/register" className="text-teal-600 dark:text-teal-400 font-medium hover:underline">sign up</Link> to like, save, and share your favorite observations.
          </p>
        </div>
      )}
    </div>
  );
};

export default ObservationFeed;

---

<client\src\components\movie-observations\QuickStats.jsx>


import React from 'react';

const QuickStats = ({ totalCount, filteredCount, activeCategory, type = "observations" }) => {
  const itemType = type === "observations" ? "observation" : "analysis";
  const itemTypePlural = type === "observations" ? "observations" : "analyses";
  
  return (
    <div className="flex items-center justify-between mb-4">
      <div className="text-sm text-gray-600 dark:text-slate-400">
        {activeCategory === 'All' ? (
          `Showing ${totalCount} ${totalCount !== 1 ? itemTypePlural : itemType}`
        ) : (
          `Showing ${filteredCount} of ${totalCount} ${totalCount !== 1 ? itemTypePlural : itemType}`
        )}
      </div>
    </div>
  );
};

export default QuickStats;

---

<client\src\components\movie-observations\SceneDetail.jsx>

// client/src/components/movie-observations/SceneDetail.jsx

import { useState } from 'react';
import { Share2, Check, Edit, GitPullRequestCreate, Trash2 } from 'lucide-react';
import { useAuth } from '../../context/AuthContext';
import SceneFrame from './SceneFrame';

const SceneDetail = ({ sceneData, selectedScene, movieDetails, onSuggestEdit, onEditScene, onDeleteScene }) => {
    const { user } = useAuth();
    const [copied, setCopied] = useState(false);

    const handleCite = () => {
        const url = window.location.href;
        const citation = `${url}\nScene ${selectedScene} (${sceneData.startTime} - ${sceneData.endTime}) from ${movieDetails.title} (${movieDetails.release_date?.substring(0,4)}).`;
        navigator.clipboard.writeText(citation);
        setCopied(true);
        setTimeout(() => setCopied(false), 2000);
    };

    return (
        <div className="bg-white dark:bg-slate-800 border border-gray-200 dark:border-slate-700 rounded-lg p-6 mb-6 transition-colors">
            <div className="flex justify-between items-start mb-2 gap-4">
                <h2 className="text-lg font-semibold text-gray-900 dark:text-slate-100">Scene {selectedScene}: Context</h2>
                <div className="flex items-center flex-shrink-0 gap-2">
                    {user && (
                        user.role === 'admin' ? (
                            <>
                                <button onClick={onEditScene} className="flex items-center gap-1.5 px-3 py-1.5 text-xs font-semibold bg-gray-100 dark:bg-slate-700 hover:bg-gray-200 dark:hover:bg-slate-600 rounded-full transition-colors">
                                    <Edit size={14} /> Edit
                                </button>
                                <button onClick={onDeleteScene} className="flex items-center gap-1.5 px-3 py-1.5 text-xs font-semibold bg-red-100 dark:bg-red-900/40 text-red-700 dark:text-red-300 hover:bg-red-200 dark:hover:bg-red-900/60 rounded-full transition-colors">
                                    <Trash2 size={14} /> Delete
                                </button>
                            </>
                        ) : (
                            <button onClick={() => onSuggestEdit('EDIT_SCENE')} className="flex items-center gap-2 px-3 py-1.5 text-xs font-semibold bg-gray-100 dark:bg-slate-700 hover:bg-gray-200 dark:hover:bg-slate-600 rounded-full transition-colors">
                                <GitPullRequestCreate size={14} /> Suggest Edit
                            </button>
                        )
                    )}
                    <button onClick={handleCite} className="flex items-center gap-2 px-3 py-1.5 text-xs font-semibold bg-gray-100 dark:bg-slate-700 hover:bg-gray-200 dark:hover:bg-slate-600 rounded-full transition-colors">
                        {copied ? <Check size={14} className="text-green-500"/> : <Share2 size={14} />}
                        {copied ? 'Copied!' : 'Cite'}
                    </button>
                </div>
            </div>
            <p className="text-gray-600 dark:text-slate-300 text-sm mb-4">{sceneData.description}</p>
            
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                <SceneFrame
                    label="START"
                    timestamp={sceneData.startTime}
                    imageUrl={sceneData.startFrameUrl}
                    alt={`Scene ${selectedScene} Start`}
                />
                <SceneFrame
                    label="END"
                    timestamp={sceneData.endTime}
                    imageUrl={sceneData.endFrameUrl}
                    alt={`Scene ${selectedScene} End`}
                />
            </div>
        </div>
    );
};

export default SceneDetail;

---

<client\src\components\movie-observations\SceneFrame.jsx>

// client/src/components/movie-observations/SceneFrame.jsx

import React from 'react';
import { ImageOff } from 'lucide-react';

const SceneFrame = ({ label, timestamp, imageUrl, alt }) => {
    return (
        <div>
            <span className="text-xs font-semibold text-gray-500 dark:text-slate-400">
                {label} â€¢ {timestamp}
            </span>
            {imageUrl ? (
                // If the image URL exists, display the image
                <img 
                    src={imageUrl} 
                    alt={alt} 
                    className="mt-1 w-full h-40 object-cover rounded-md border dark:border-slate-600 bg-gray-200 dark:bg-slate-700"
                />
            ) : (
                // If the URL is missing, display a helpful placeholder
                <div className="mt-1 w-full h-40 flex flex-col items-center justify-center bg-gray-100 dark:bg-slate-700/50 rounded-md border-2 border-dashed border-gray-300 dark:border-slate-600">
                    <ImageOff className="w-8 h-8 text-gray-400 dark:text-slate-500 mb-2" />
                    <p className="text-xs text-center text-gray-500 dark:text-slate-400">
                        Image not available.
                    </p>
                    <p className="text-xs text-center text-teal-600 dark:text-teal-400 font-semibold">
                        Suggest an edit to add it!
                    </p>
                </div>
            )}
        </div>
    );
};

export default SceneFrame;

---

<client\src\components\movie-observations\SceneListSidebar.jsx>

import React from 'react';
import { Plus, GitPullRequestCreate } from 'lucide-react';

const SceneListSidebar = ({ scenes, selectedScene, onSelectScene, user, authLoading, onManageScenesClick, onSuggestNewSceneClick }) => {
    return (
        <aside className="w-80 bg-white dark:bg-slate-900 border-r border-gray-200 dark:border-slate-800 flex-col fixed top-16 left-0 h-[calc(100vh-4rem)] z-10 hidden lg:flex transition-colors">
            <nav className="flex-grow p-4 overflow-y-auto">
                <h3 className="px-2 text-sm font-semibold text-gray-500 dark:text-slate-500 uppercase tracking-wider mb-2">Scenes</h3>
                {scenes.length > 0 ? (
                    <ul>
                        {scenes.map(({ sceneNumber, description }) => (
                            <li key={sceneNumber}>
                                <button
                                    onClick={() => onSelectScene(sceneNumber)}
                                    className={`w-full text-left px-3 py-2.5 rounded-md transition-colors text-sm flex flex-col ${
                                        selectedScene === sceneNumber 
                                        ? "bg-teal-600 text-white shadow-sm" 
                                        : "hover:bg-gray-100 dark:hover:bg-slate-800 text-gray-700 dark:text-slate-300"
                                    }`}
                                >
                                    <span className="font-semibold">Scene {sceneNumber}</span>
                                    <span className={`transition-opacity ${selectedScene === sceneNumber ? "opacity-70" : "opacity-100"}`}>{description.substring(0, 40)}...</span>
                                </button>
                            </li>
                        ))}
                    </ul>
                ) : (
                    <p className="px-3 text-sm text-gray-500 dark:text-slate-400">No scenes have been added for this movie.</p>
                )}
            </nav>
            <div className="p-4 border-t border-gray-200 dark:border-slate-800 space-y-2">
                {!authLoading && user && (
                    user.role === 'admin' ? (
                        <button onClick={onManageScenesClick} className="w-full flex items-center justify-center gap-2 px-3 py-2 text-sm font-medium text-white bg-teal-600 hover:bg-teal-700 rounded-md transition-colors">
                            <Plus size={16} /> Manage Scenes
                        </button>
                    ) : (
                        <button onClick={onSuggestNewSceneClick} className="w-full flex items-center justify-center gap-2 px-3 py-2 text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 rounded-md transition-colors">
                            <GitPullRequestCreate size={16} /> Suggest New Scene
                        </button>
                    )
                )}
            </div>
        </aside>
    );
};

export default SceneListSidebar;


---

<client\src\components\movie-observations\modals\ManageScenesModal.jsx>

import React, { useState, useEffect, useRef } from 'react';
import axios from '../../../api/axios';
import { Plus, X, Loader2, ImagePlus, Save } from 'lucide-react';

const ManageScenesModal = ({ isOpen, onClose, movieId, scenes, onSceneAdded, isEditing, sceneToEdit }) => {
    const [formData, setFormData] = useState({ description: '', startTime: '', endTime: '' });
    const [startFrame, setStartFrame] = useState(null);
    const [endFrame, setEndFrame] = useState(null);
    const [isSubmitting, setIsSubmitting] = useState(false);
    const [error, setError] = useState('');
    const startFrameRef = useRef(null);
    const endFrameRef = useRef(null);

    useEffect(() => {
        // Pre-populate form if in edit mode
        if (isOpen && isEditing && sceneToEdit) {
            setFormData({
                description: sceneToEdit.description || '',
                startTime: sceneToEdit.startTime || '',
                endTime: sceneToEdit.endTime || '',
            });
        } else {
            // Reset for create mode
            setFormData({ description: '', startTime: '', endTime: '' });
        }
        // Reset files and messages when modal opens/closes
        setStartFrame(null);
        setEndFrame(null);
        setError('');
    }, [isOpen, isEditing, sceneToEdit]);

    const handleFileChange = (e, setter) => setter(e.target.files[0]);

    const handleSubmit = async (e) => {
        e.preventDefault();
        setIsSubmitting(true);
        setError('');

        const submissionData = new FormData();
        submissionData.append('movieId', movieId);
        submissionData.append('description', formData.description);
        submissionData.append('startTime', formData.startTime);
        submissionData.append('endTime', formData.endTime);
        if (startFrame) submissionData.append('startFrame', startFrame);
        if (endFrame) submissionData.append('endFrame', endFrame);

        try {
            if (isEditing) {
                // UPDATE existing scene
                await axios.put(`/scenes/${sceneToEdit._id}`, submissionData, {
                    headers: { 'Content-Type': 'multipart/form-data' }
                });
            } else {
                // CREATE new scene
                const newSceneNumber = scenes.length > 0 ? Math.max(...scenes.map(s => s.sceneNumber)) + 1 : 1;
                submissionData.append('sceneNumber', newSceneNumber);
                await axios.post('/scenes', submissionData, {
                    headers: { 'Content-Type': 'multipart/form-data' }
                });
            }
            onSceneAdded(); // A generic callback to refetch scenes
            onClose();
        } catch (err) {
            setError(err.response?.data?.message || 'Failed to save scene.');
        } finally {
            setIsSubmitting(false);
        }
    };

    if (!isOpen) return null;
    const title = isEditing ? `Edit Scene ${sceneToEdit.sceneNumber}` : 'Add New Scene';

    return (
        <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50 p-4">
            <div className="bg-white dark:bg-slate-800 rounded-lg shadow-2xl w-full max-w-2xl max-h-[90vh] flex flex-col">
                <div className="border-b dark:border-slate-700 p-6 flex items-center justify-between">
                    <h2 className="text-xl font-semibold dark:text-slate-100">{title}</h2>
                    <button onClick={onClose}><X className="text-gray-400 hover:text-gray-600" size={24} /></button>
                </div>
                <form onSubmit={handleSubmit} className="flex-grow overflow-y-auto p-6 space-y-4">
                    {/* ... form fields for startTime, endTime, description ... */}
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                         <input type="text" placeholder="Start Time (e.g., 01:25:00)" value={formData.startTime} onChange={e => setFormData({...formData, startTime: e.target.value})} required className="w-full px-3 py-2 border rounded-md dark:bg-slate-700 dark:border-slate-600"/>
                         <input type="text" placeholder="End Time (e.g., 01:32:00)" value={formData.endTime} onChange={e => setFormData({...formData, endTime: e.target.value})} required className="w-full px-3 py-2 border rounded-md dark:bg-slate-700 dark:border-slate-600"/>
                    </div>
                    <textarea placeholder="Scene Description" value={formData.description} onChange={e => setFormData({...formData, description: e.target.value})} required className="w-full px-3 py-2 border rounded-md dark:bg-slate-700 dark:border-slate-600" rows={3}></textarea>
                    
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                         <button type="button" onClick={() => startFrameRef.current.click()} className="border-2 border-dashed p-4 rounded-md flex flex-col items-center justify-center text-sm text-gray-500 hover:border-teal-500 dark:border-slate-600 dark:text-slate-400">
                             <ImagePlus size={24} className="mb-2"/> {startFrame ? startFrame.name : (isEditing ? 'Upload New Start Frame' : 'Upload Start Frame')}
                         </button>
                         <input type="file" ref={startFrameRef} onChange={(e) => handleFileChange(e, setStartFrame)} className="hidden" accept="image/*"/>
                         <button type="button" onClick={() => endFrameRef.current.click()} className="border-2 border-dashed p-4 rounded-md flex flex-col items-center justify-center text-sm text-gray-500 hover:border-teal-500 dark:border-slate-600 dark:text-slate-400">
                             <ImagePlus size={24} className="mb-2"/> {endFrame ? endFrame.name : (isEditing ? 'Upload New End Frame' : 'Upload End Frame')}
                         </button>
                         <input type="file" ref={endFrameRef} onChange={(e) => handleFileChange(e, setEndFrame)} className="hidden" accept="image/*"/>
                    </div>
                    
                    {error && <p className="text-sm text-red-600 text-center w-full">{error}</p>}
                    
                    <div className="border-t dark:border-slate-700 pt-4 flex justify-end gap-3">
                         <button type="button" onClick={onClose} className="px-4 py-2 text-sm font-medium bg-gray-200 dark:bg-slate-600 rounded-md hover:bg-gray-300 dark:hover:bg-slate-500">Cancel</button>
                         <button type="submit" disabled={isSubmitting} className="flex items-center gap-2 px-4 py-2 bg-teal-600 text-white rounded-md text-sm font-medium hover:bg-teal-700 disabled:opacity-50">
                             {isSubmitting ? <Loader2 className="animate-spin" size={16}/> : (isEditing ? <Save size={16}/> : <Plus size={16}/>)}
                             {isEditing ? 'Save Changes' : 'Add Scene'}
                         </button>
                    </div>
                </form>
            </div>
        </div>
    );
};

export default ManageScenesModal;

---

<client\src\components\movie-observations\modals\NewObservationModal.jsx>

import React, { useState, useEffect } from 'react';
import axios from '../../../api/axios';
import { Plus, X, Loader2 } from 'lucide-react';

const NewObservationModal = ({ isOpen, onClose, movieId, selectedScene, sceneData, onObservationAdded }) => {
  const [formData, setFormData] = useState({ content: '', categories: [], timestamp: '' });
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState('');

  const categories = [
      "Cinematography",
      "Editing",
      "Sound & Music",
      "Symbolism",
      "Foreshadowing",
      "Character Arc",
      "Dialogue",
      "Pacing",
      "World-Building",
      "Costume & Set Design",
      "Visual Effects",
      "Performance / Acting",
      "Other"
  ];
  
  const handleCategoryToggle = (category) => {
    setFormData((prev) => ({
      ...prev,
      categories: prev.categories.includes(category)
        ? prev.categories.filter((c) => c !== category)
        : [...prev.categories, category],
    }));
  };

  const handleSubmit = async () => {
    if (isSubmitting || !formData.content.trim() || formData.categories.length === 0) return;
    setIsSubmitting(true);
    setError('');
    try {
      const payload = { ...formData, movieId, sceneId: String(selectedScene) };
      const res = await axios.post('/observations', payload);
      onObservationAdded(res.data);
      onClose();
    } catch (err) {
      setError(err.response?.data?.message || 'Failed to post observation.');
    } finally {
      setIsSubmitting(false);
    }
  };

  useEffect(() => {
    if (!isOpen) {
      setFormData({ content: '', categories: [], timestamp: '' });
      setError('');
    }
  }, [isOpen]);

  if (!isOpen) return null;
  const currentScene = sceneData || {};

  return (
    <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50 p-4">
      <div className="bg-white dark:bg-slate-800 rounded-lg shadow-2xl w-full max-w-2xl max-h-[90vh] flex flex-col">
        <div className="border-b border-gray-200 dark:border-slate-700 p-6 flex items-start justify-between">
          <div>
            <h2 className="text-xl font-semibold text-gray-900 dark:text-slate-100">New Observation</h2>
            <p className="text-sm text-gray-600 dark:text-slate-400">Scene {selectedScene} â€¢ {currentScene.startTime} - {currentScene.endTime}</p>
          </div>
          <button onClick={onClose} className="text-gray-400 dark:text-slate-400 hover:text-gray-600 dark:hover:text-slate-200 transition-colors"><X size={24} /></button>
        </div>
        
        <div className="p-6 overflow-y-auto flex-grow space-y-6">
            <div className="bg-gray-50 dark:bg-slate-700/50 rounded-lg p-4 border border-gray-200 dark:border-slate-700">
                <h3 className="font-medium text-gray-900 dark:text-slate-200 mb-2">Scene Context</h3>
                <p className="text-sm text-gray-700 dark:text-slate-300">{currentScene.description}</p>
            </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-slate-300 mb-2">Timestamp (optional)</label>
                <input type="text" value={formData.timestamp} onChange={(e) => setFormData(prev => ({ ...prev, timestamp: e.target.value }))} placeholder="e.g., 3:41" className="w-full px-3 py-2 border border-gray-300 dark:border-slate-600 bg-white dark:bg-slate-700 text-gray-900 dark:text-slate-200 rounded-md placeholder:text-gray-400 dark:placeholder:text-slate-400"/>
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-slate-300 mb-2">Your Observation *</label>
                <textarea value={formData.content} onChange={(e) => setFormData(prev => ({ ...prev, content: e.target.value }))} placeholder="Share your observation..." rows={4} className="w-full px-3 py-2 border border-gray-300 dark:border-slate-600 bg-white dark:bg-slate-700 text-gray-900 dark:text-slate-200 rounded-md placeholder:text-gray-400 dark:placeholder:text-slate-400"></textarea>
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-slate-300 mb-3">Categories (select up to 3)</label>
                <div className="flex flex-wrap gap-2">
                    {categories.map((category) => (
                        <button key={category} type="button" onClick={() => handleCategoryToggle(category)} disabled={!formData.categories.includes(category) && formData.categories.length >= 3} className={`px-3 py-1.5 text-sm rounded-full border transition-all ${formData.categories.includes(category) ? 'bg-teal-600 text-white border-teal-600' : 'bg-white dark:bg-slate-700 text-gray-700 dark:text-slate-300 border-gray-300 dark:border-slate-600 hover:border-teal-500 disabled:opacity-50'}`}>
                            {category}
                        </button>
                    ))}
                </div>
              </div>
        </div>

        <div className="border-t border-gray-200 dark:border-slate-700 p-4 bg-gray-50 dark:bg-slate-800/50 flex flex-col items-end gap-3">
          {error && <p className="text-sm text-red-600 w-full text-left">{error}</p>}
          <div className="flex gap-3">
            <button onClick={onClose} className="px-4 py-2 text-sm font-medium text-gray-700 dark:text-slate-200 bg-white dark:bg-slate-600 border border-gray-300 dark:border-slate-500 rounded-md hover:bg-gray-50 dark:hover:bg-slate-500 transition-colors">Cancel</button>
            <button onClick={handleSubmit} disabled={isSubmitting || !formData.content.trim() || formData.categories.length === 0} className="flex items-center gap-2 px-4 py-2 text-sm font-medium bg-teal-600 text-white rounded-md hover:bg-teal-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
              {isSubmitting ? <Loader2 className="animate-spin" size={16} /> : <Plus size={16} />}
              {isSubmitting ? 'Posting...' : 'Post Observation'}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

export default NewObservationModal;


---

<client\src\components\movie-observations\modals\SuggestionModal.jsx>

import React, { useState, useEffect, useRef } from 'react';
import axios from '../../../api/axios';
import { Plus, X, Loader2, ImagePlus } from 'lucide-react';

const SuggestionModal = ({ isOpen, onClose, movieId, suggestionType, sceneToEdit, scenes }) => {
    const [formData, setFormData] = useState({ description: '', startTime: '', endTime: '', notes: '' });
    const [startFrame, setStartFrame] = useState(null);
    const [endFrame, setEndFrame] = useState(null);
    const [isSubmitting, setIsSubmitting] = useState(false);
    const [error, setError] = useState('');
    const [successMessage, setSuccessMessage] = useState('');
    const startFrameRef = useRef(null);
    const endFrameRef = useRef(null);

    useEffect(() => {
        if (isOpen && suggestionType === 'EDIT_SCENE' && sceneToEdit) {
            setFormData({
                description: sceneToEdit.description || '',
                startTime: sceneToEdit.startTime || '',
                endTime: sceneToEdit.endTime || '',
                notes: ''
            });
        } else {
            setFormData({ description: '', startTime: '', endTime: '', notes: '' });
        }
        setStartFrame(null);
        setEndFrame(null);
        setError('');
        setSuccessMessage('');
    }, [isOpen, suggestionType, sceneToEdit]);

    const handleFileChange = (e, setter) => setter(e.target.files[0]);

    const handleSubmit = async (e) => {
        e.preventDefault();
        setError('');
        
        // Check if at least one change has been made.
        const hasTextChanged = 
            (suggestionType === 'EDIT_SCENE') 
            ? formData.description !== sceneToEdit.description ||
              formData.startTime !== sceneToEdit.startTime ||
              formData.endTime !== sceneToEdit.endTime
            : formData.description || formData.startTime || formData.endTime;

        const hasFilesChanged = startFrame || endFrame;
        
        if (!hasTextChanged && !hasFilesChanged) {
            setError('You must suggest at least one change.');
            return;
        }

        setIsSubmitting(true);
        setSuccessMessage('');

        const submissionData = new FormData();
        submissionData.append('movieId', movieId);
        submissionData.append('suggestionType', suggestionType);
        if (suggestionType === 'EDIT_SCENE') {
            submissionData.append('sceneToEdit', sceneToEdit._id);
        } else {
            const newSceneNumber = scenes.length > 0 ? Math.max(...scenes.map(s => s.sceneNumber)) + 1 : 1;
            submissionData.append('sceneNumber', newSceneNumber);
        }
        
        Object.keys(formData).forEach(key => submissionData.append(key, formData[key]));
        if (startFrame) submissionData.append('startFrame', startFrame);
        if (endFrame) submissionData.append('endFrame', endFrame);

        try {
            const res = await axios.post('/suggestions', submissionData, {
                headers: { 'Content-Type': 'multipart/form-data' }
            });
            setSuccessMessage(res.data.message);
            setTimeout(onClose, 2000);
        } catch (err) {
            setError(err.response?.data?.message || 'Failed to submit suggestion.');
        } finally {
            setIsSubmitting(false);
        }
    };

    if (!isOpen) return null;
    const title = suggestionType === 'NEW_SCENE' ? 'Suggest a New Scene' : `Suggest Edits for Scene ${sceneToEdit?.sceneNumber}`;

    return (
        <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50 p-4">
            <div className="bg-white dark:bg-slate-800 rounded-lg shadow-2xl w-full max-w-2xl max-h-[90vh] flex flex-col">
                <div className="border-b dark:border-slate-700 p-6 flex items-center justify-between">
                    <h2 className="text-xl font-semibold dark:text-slate-100">{title}</h2>
                    <button onClick={onClose}><X className="text-gray-400 hover:text-gray-600" size={24} /></button>
                </div>
                <form onSubmit={handleSubmit} className="flex-grow overflow-y-auto p-6 space-y-4">
                    {/* --- REMOVED: 'required' attribute from all fields --- */}
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                         <input type="text" placeholder="Start Time (e.g., 01:25:00)" value={formData.startTime} onChange={e => setFormData({...formData, startTime: e.target.value})} className="w-full px-3 py-2 border rounded-md dark:bg-slate-700 dark:border-slate-600"/>
                         <input type="text" placeholder="End Time (e.g., 01:32:00)" value={formData.endTime} onChange={e => setFormData({...formData, endTime: e.target.value})} className="w-full px-3 py-2 border rounded-md dark:bg-slate-700 dark:border-slate-600"/>
                    </div>
                    <textarea placeholder="Scene Description" value={formData.description} onChange={e => setFormData({...formData, description: e.target.value})} className="w-full px-3 py-2 border rounded-md dark:bg-slate-700 dark:border-slate-600" rows={3}></textarea>
                    
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                         <button type="button" onClick={() => startFrameRef.current.click()} className="border-2 border-dashed p-4 rounded-md flex flex-col items-center justify-center text-sm text-gray-500 hover:border-teal-500 dark:border-slate-600 dark:text-slate-400">
                             <ImagePlus size={24} className="mb-2"/> {startFrame ? startFrame.name : 'Upload Start Frame'}
                         </button>
                         <input type="file" ref={startFrameRef} onChange={(e) => handleFileChange(e, setStartFrame)} className="hidden" accept="image/*"/>
                         <button type="button" onClick={() => endFrameRef.current.click()} className="border-2 border-dashed p-4 rounded-md flex flex-col items-center justify-center text-sm text-gray-500 hover:border-teal-500 dark:border-slate-600 dark:text-slate-400">
                             <ImagePlus size={24} className="mb-2"/> {endFrame ? endFrame.name : 'Upload End Frame'}
                         </button>
                         <input type="file" ref={endFrameRef} onChange={(e) => handleFileChange(e, setEndFrame)} className="hidden" accept="image/*"/>
                    </div>
                    <textarea placeholder="Optional: Add a note for the admin explaining your change." value={formData.notes} onChange={e => setFormData({...formData, notes: e.target.value})} className="w-full px-3 py-2 border rounded-md dark:bg-slate-700 dark:border-slate-600" rows={2}></textarea>

                    {error && <p className="text-sm text-red-600">{error}</p>}
                    {successMessage && <p className="text-sm text-green-600">{successMessage}</p>}

                    <div className="border-t dark:border-slate-700 pt-4 flex justify-end gap-3">
                         <button type="button" onClick={onClose} className="px-4 py-2 text-sm font-medium bg-gray-200 dark:bg-slate-600 rounded-md hover:bg-gray-300 dark:hover:bg-slate-500">Cancel</button>
                         <button type="submit" disabled={isSubmitting} className="flex items-center gap-2 px-4 py-2 text-sm font-medium bg-teal-600 text-white rounded-md hover:bg-teal-700 disabled:opacity-50">
                             {isSubmitting ? <Loader2 className="animate-spin" size={16}/> : <Plus size={16}/>}
                             Submit Suggestion
                         </button>
                    </div>
                </form>
            </div>
        </div>
    );
};

export default SuggestionModal;

---

<client\src\components\movie-observations\modals\UploadAnalysisModal.jsx>

import React, { useState, useEffect, useRef } from 'react';
import axios from '../../../api/axios';
import { Upload, X, Loader2 } from 'lucide-react';

const UploadAnalysisModal = ({ isOpen, onClose, movieId, onAnalysisAdded }) => {
    const [formData, setFormData] = useState({ title: "", description: "" });
    const [file, setFile] = useState(null);
    const [isSubmitting, setIsSubmitting] = useState(false);
    const [error, setError] = useState('');
    const fileInputRef = useRef(null);

    const handleSubmit = async () => {
        if (!formData.title || !formData.description || !file || isSubmitting) return;
        setIsSubmitting(true);
        setError('');
        
        const submissionData = new FormData();
        submissionData.append('movieId', movieId);
        submissionData.append('title', formData.title);
        submissionData.append('description', formData.description);
        submissionData.append('analysisFile', file);

        try {
            const res = await axios.post('/analyses', submissionData, {
                headers: { 'Content-Type': 'multipart/form-data' }
            });
            onAnalysisAdded(res.data);
            onClose();
        } catch (err) {
            setError(err.response?.data?.message || 'Failed to upload analysis.');
        } finally {
            setIsSubmitting(false);
        }
    };
    
    useEffect(() => {
        if (!isOpen) {
            setFormData({ title: "", description: "" });
            setFile(null);
            setError('');
        }
    }, [isOpen]);

    if (!isOpen) return null;
    
    return (
        <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50 p-4">
            <div className="bg-white dark:bg-slate-800 rounded-lg shadow-2xl w-full max-w-2xl max-h-[90vh] flex flex-col">
                <div className="border-b dark:border-slate-700 p-6 flex items-center justify-between">
                    <h2 className="text-xl font-semibold dark:text-slate-100">Upload Analysis</h2>
                    <button onClick={onClose} className="text-gray-400 dark:text-slate-400 hover:text-gray-600 dark:hover:text-slate-200"><X size={24} /></button>
                </div>
                <div className="p-6 overflow-y-auto flex-grow space-y-4">
                    <input type="text" placeholder="Analysis Title" value={formData.title} onChange={e => setFormData({...formData, title: e.target.value})} className="w-full px-3 py-2 border border-gray-300 dark:border-slate-600 bg-white dark:bg-slate-700 text-gray-900 dark:text-slate-200 rounded-md placeholder:text-gray-400 dark:placeholder:text-slate-400" required/>
                    <textarea placeholder="Brief Description" value={formData.description} onChange={e => setFormData({...formData, description: e.target.value})} className="w-full px-3 py-2 border border-gray-300 dark:border-slate-600 bg-white dark:bg-slate-700 text-gray-900 dark:text-slate-200 rounded-md placeholder:text-gray-400 dark:placeholder:text-slate-400" rows={4} required></textarea>
                    <button type="button" onClick={() => fileInputRef.current.click()} className="w-full border-2 border-dashed border-gray-300 dark:border-slate-600 p-4 rounded-md flex flex-col items-center justify-center text-sm text-gray-500 dark:text-slate-400 hover:border-teal-500">
                        <Upload size={24} className="mb-2"/> {file ? file.name : 'Upload PDF Analysis'}
                    </button>
                    <input type="file" ref={fileInputRef} onChange={(e) => setFile(e.target.files[0])} className="hidden" accept=".pdf" />
                </div>
                <div className="border-t dark:border-slate-700 p-4 bg-gray-50 dark:bg-slate-800/50 flex justify-end gap-3">
                    <button onClick={onClose} className="px-4 py-2 text-sm font-medium text-gray-700 dark:text-slate-200 bg-white dark:bg-slate-600 border border-gray-300 dark:border-slate-500 rounded-md hover:bg-gray-50 dark:hover:bg-slate-500">Cancel</button>
                    <button onClick={handleSubmit} disabled={isSubmitting || !formData.title || !formData.description || !file} className="flex items-center gap-2 px-4 py-2 text-sm font-medium bg-teal-600 text-white rounded-md hover:bg-teal-700 disabled:opacity-50">
                        {isSubmitting ? <Loader2 className="animate-spin" size={16}/> : <Upload size={16}/>}
                        {isSubmitting ? "Uploading..." : "Upload Analysis"}
                    </button>
                </div>
            </div>
        </div>
    );
};

export default UploadAnalysisModal;


---

<client\src\components\movie-observations\posts\AnalysisPost.jsx>

import React from 'react';
import { ThumbsUp, Bookmark, Share2, MoreHorizontal, UserCircle, FileText, Download } from 'lucide-react';
import { formatDistanceToNow } from 'date-fns';

const AnalysisPost = ({ analysis, user, onLike, onBookmark }) => {
    const isLiked = user && analysis.likes.includes(user._id);
    const isBookmarked = user && user.analysisBookmarks?.includes(analysis._id);

    const handleShare = () => {
        const url = `${window.location.origin}/movie/${analysis.movieId}`;
        navigator.clipboard.writeText(url)
            .then(() => alert("Link copied to clipboard!"))
            .catch(err => console.error('Failed to copy text: ', err));
    };

    const formatBytes = (bytes, decimals = 2) => {
        if (!bytes) return '0 Bytes';
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    };

    const cloudName = import.meta.env.VITE_CLOUDINARY_CLOUD_NAME;

    const rawFilename = `${analysis.title}_by_${analysis.user?.username || 'User'}`;
    const safeFilename = rawFilename.replace(/[^a-zA-Z0-9_\-]/g, '_');
    
    const downloadUrl = analysis.filePublicId
        ? `https://res.cloudinary.com/${cloudName}/raw/upload/fl_attachment:${safeFilename}/${analysis.filePublicId}`
        : '#';
    
    return (
        <div className="bg-white dark:bg-slate-800 border border-gray-200 dark:border-slate-700 rounded-lg p-6 mb-4 transition-colors shadow-sm hover:shadow-md">
            <div className="flex items-start gap-4">
                <UserCircle className="text-gray-400 dark:text-slate-500 flex-shrink-0" size={40} />
                <div className="flex-1 min-w-0">
                    <div className="flex items-center gap-2 mb-2">
                        <span className="font-semibold text-gray-900 dark:text-slate-100">{analysis.user?.username || 'User'}</span>
                        <span className="text-gray-500 dark:text-slate-400 text-sm font-light">â€¢ {formatDistanceToNow(new Date(analysis.createdAt), { addSuffix: true })}</span>
                    </div>
                    <h3 className="font-semibold text-lg text-gray-900 dark:text-slate-100 mb-2">{analysis.title}</h3>
                    <p className="text-gray-700 dark:text-slate-300 mb-4 leading-relaxed">{analysis.description}</p>
                    
                    <a href={downloadUrl} download={safeFilename} target="_blank" rel="noopener noreferrer" className="inline-flex items-center gap-3 bg-gray-100 dark:bg-slate-700 hover:bg-gray-200 dark:hover:bg-slate-600 transition-colors rounded-lg p-3 border dark:border-slate-600 mb-4 text-sm w-full sm:w-auto">
                        <FileText size={24} className="text-teal-600 flex-shrink-0" />
                        <div className='min-w-0'>
                            <span className="font-medium text-gray-800 dark:text-slate-200 truncate block">{analysis.title}.pdf</span>
                            <span className="text-gray-500 dark:text-slate-400 block">{formatBytes(analysis.fileSize)}</span>
                        </div>
                        <Download size={16} className="ml-auto text-gray-500 dark:text-slate-400 flex-shrink-0" />
                    </a>

                    <div className="flex items-center gap-5 text-gray-500 dark:text-slate-400 mt-2">
                        <button onClick={() => onLike(analysis._id)} className={`flex items-center gap-1.5 hover:text-teal-600 transition-colors group ${isLiked ? 'text-teal-600' : ''}`}>
                            <ThumbsUp size={16} fill={isLiked ? 'currentColor' : 'none'} />
                            <span className="text-sm font-medium">{analysis.likes?.length || 0}</span>
                        </button>
                        <button onClick={() => onBookmark(analysis._id)} className={`hover:text-teal-600 transition-colors group ml-auto ${isBookmarked ? 'text-yellow-500' : ''}`}>
                             <Bookmark size={16} fill={isBookmarked ? 'currentColor' : 'none'} />
                        </button>
                        <button onClick={handleShare} className="hover:text-teal-600 transition-colors group"><Share2 size={16} /></button>
                    </div>
                </div>
                <button className="text-gray-400 dark:text-slate-400 hover:text-gray-600 dark:hover:text-slate-200 transition-colors"><MoreHorizontal size={20} /></button>
            </div>
        </div>
    );
};

export default AnalysisPost;


---

<client\src\components\movie-observations\posts\ObservationPost.jsx>

import React from 'react';
import { ThumbsUp, Bookmark, Share2, MoreHorizontal, UserCircle } from 'lucide-react';
import { formatDistanceToNow } from 'date-fns';

const ObservationPost = ({ observation, onLike, onBookmark, user }) => {
    const isLiked = user && observation.likes.includes(user._id);
    const isBookmarked = user && user.bookmarks?.includes(observation._id);

    const handleShare = () => {
        const url = `${window.location.origin}/movie/${observation.movieId}`;
        navigator.clipboard.writeText(url)
            .then(() => alert("Link copied to clipboard!"))
            .catch(err => console.error('Failed to copy text: ', err));
    };

    return (
        <div className="bg-white dark:bg-slate-800 border border-gray-200 dark:border-slate-700 rounded-lg p-5 mb-4 transition-colors shadow-sm hover:shadow-md">
            <div className="flex items-start gap-4">
                <UserCircle className="text-gray-400 dark:text-slate-500 flex-shrink-0" size={40} />
                <div className="flex-1 min-w-0">
                    <div className="flex items-center gap-2 mb-1">
                        <span className="font-semibold text-gray-900 dark:text-slate-100">{observation.user?.username || 'User'}</span>
                        <span className="text-gray-500 dark:text-slate-400 text-sm font-light">â€¢ {formatDistanceToNow(new Date(observation.createdAt), { addSuffix: true })}</span>
                    </div>
                    <p className="text-gray-800 dark:text-slate-300 mb-3 leading-relaxed">{observation.content}</p>
                    <div className="flex flex-wrap gap-2 mb-4">
                        {observation.categories.map((category) => (
                            <span key={category} className="bg-teal-100 dark:bg-teal-500/20 text-teal-800 dark:text-teal-300 text-xs font-medium px-2.5 py-1 rounded-full">{category}</span>
                        ))}
                    </div>
                    <div className="flex items-center gap-5 text-gray-500 dark:text-slate-400">
                        <button onClick={() => onLike(observation._id)} className={`flex items-center gap-1.5 hover:text-teal-600 transition-colors group ${isLiked ? 'text-teal-600' : ''}`}>
                            <ThumbsUp size={16} fill={isLiked ? 'currentColor' : 'none'} />
                            <span className="text-sm font-medium">{observation.likes?.length || 0}</span>
                        </button>
                        <button onClick={() => onBookmark(observation._id)} className={`hover:text-teal-600 transition-colors group ml-auto ${isBookmarked ? 'text-yellow-500' : ''}`}>
                            <Bookmark size={16} fill={isBookmarked ? 'currentColor' : 'none'} />
                        </button>
                        <button onClick={handleShare} className="hover:text-teal-600 transition-colors group"><Share2 size={16} /></button>
                    </div>
                </div>
                <button className="text-gray-400 dark:text-slate-400 hover:text-gray-600 dark:hover:text-slate-200 transition-colors"><MoreHorizontal size={20} /></button>
            </div>
        </div>
    );
};

export default ObservationPost;


---

<client\src\context\AuthContext.jsx>

import { createContext, useContext, useEffect, useState } from 'react'
import axios from '../api/axios'

const AuthContext = createContext()

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    const fetchUser = async () => {
      try {
        const { data } = await axios.get('/auth/me')
        setUser(data)
      } catch {
        setUser(null)
      } finally {
        setLoading(false)
      }
    }
    fetchUser()
  }, [])

  // --- MODIFIED: Login function now just sets the user state ---
  const login = (userData) => {
    setUser(userData);
  };

  const logout = async () => {
    await axios.post('/auth/logout')
    setUser(null)
  }

  return (
    <AuthContext.Provider value={{ user, loading, login, logout, setUser }}>
      {children}
    </AuthContext.Provider>
  )
}

export const useAuth = () => useContext(AuthContext)

---

<client\src\context\ThemeContext.jsx>

import React, { createContext, useContext, useEffect, useState } from 'react';

const ThemeContext = createContext();

export const ThemeProvider = ({ children }) => {
    const [theme, setTheme] = useState(() => {
        if (typeof window !== 'undefined') {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                return savedTheme;
            }
            return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        }
        return 'light';
    });

    useEffect(() => {
        const root = window.document.documentElement;

        if (theme === 'dark') {
            root.setAttribute('data-theme', 'dark');
        } else {
            root.removeAttribute('data-theme');
        }

        localStorage.setItem('theme', theme);
    }, [theme]);

    const toggleTheme = () => {
        console.log("Toggling theme!"); // <-- Add this line
        setTheme((prevTheme) => (prevTheme === 'light' ? 'dark' : 'light'));
    };

    return (
        <ThemeContext.Provider value={{ theme, toggleTheme }}>
            {children}
        </ThemeContext.Provider>
    );
};

export const useTheme = () => useContext(ThemeContext);


---

<client\src\hooks\useMovieData.js>

import { useState, useEffect } from 'react';
import { useParams } from 'react-router-dom';
import axios from '../api/axios';

export const useMovieData = () => {
    const { id: movieId } = useParams();
    
    // All data-related state is now managed here
    const [movieDetails, setMovieDetails] = useState(null);
    const [scenes, setScenes] = useState([]);
    const [observations, setObservations] = useState([]);
    const [analyses, setAnalyses] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    const fetchAllData = async () => {
        if (!movieId) return;
        setLoading(true);
        setError(null);
        try {
            const [detailsRes, scenesRes, obsRes, anlsRes] = await Promise.all([
                axios.get(`/movies/${movieId}`),
                axios.get(`/scenes/${movieId}`),
                axios.get(`/observations/${movieId}`),
                axios.get(`/analyses/${movieId}`),
            ]);
            
            setMovieDetails(detailsRes.data);
            
            const sortedScenes = scenesRes.data.sort((a, b) => a.sceneNumber - b.sceneNumber);
            setScenes(sortedScenes);
            
            setObservations(obsRes.data);
            setAnalyses(anlsRes.data);

        } catch(err) { 
            console.error("Failed to fetch page data:", err);
            setError("Could not load data for this film. Please try again later.");
        } finally { 
            setLoading(false);
        }
    };

    useEffect(() => {
        fetchAllData();
    }, [movieId]);

    // The hook returns the state and setters for the component to use
    return {
        movieId,
        movieDetails,
        scenes,
        setScenes,
        observations,
        setObservations,
        analyses,
        setAnalyses,
        loading,
        error,
        fetchAllData
    };
};

---

<client\src\hooks\useMovies.js>



---

<client\src\pages\AdminDashboard.jsx>

import React, { useState } from 'react';
import { ShieldCheck } from 'lucide-react';
import UserPageLayout from '../components/UserPageLayout';
import SuggestionReviewPanel from '../components/admin/SuggestionReviewPanel'; 
import UserManagementPanel from '../components/admin/UserManagementPanel';

export default function AdminDashboard() {
    const [activeTab, setActiveTab] = useState('suggestions');

    return (
        <UserPageLayout title="Admin Dashboard" icon={ShieldCheck}>
            {/* Tab Navigation */}
            <div className="mb-6 border-b border-gray-200 dark:border-slate-700">
                <nav className="-mb-px flex space-x-6" aria-label="Tabs">
                    <button
                        onClick={() => setActiveTab('suggestions')}
                        className={`${
                            activeTab === 'suggestions'
                                ? 'border-teal-500 text-teal-600 dark:text-teal-400'
                                : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 dark:text-slate-400 dark:hover:text-slate-200 dark:hover:border-slate-600'
                        } whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm transition-colors`}
                    >
                        Pending Suggestions
                    </button>
                    <button
                        onClick={() => setActiveTab('users')}
                        className={`${
                            activeTab === 'users'
                                ? 'border-teal-500 text-teal-600 dark:text-teal-400'
                                : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 dark:text-slate-400 dark:hover:text-slate-200 dark:hover:border-slate-600'
                        } whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm transition-colors`}
                    >
                        User Management
                    </button>
                </nav>
            </div>

            {/* Content based on active tab */}
            <div>
                {activeTab === 'suggestions' && <SuggestionReviewPanel />}
                {activeTab === 'users' && <UserManagementPanel />}
            </div>
        </UserPageLayout>
    );
}

---

<client\src\pages\AdminLogin.jsx>

import { AuthForm } from './AuthForms'
export default function AdminLogin() { return <AuthForm type="login" role="admin" /> }


---

<client\src\pages\AdminRegister.jsx>

import { AuthForm } from './AuthForms'
export default function AdminRegister() { return <AuthForm type="register" role="admin" /> }


---

<client\src\pages\AuthForms.jsx>

import { useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import axios from '../api/axios'; // Use the configured axios instance
import { useAuth } from '../context/AuthContext';
import { User, Mail, KeyRound, Loader2, AlertCircle, CheckCircle } from 'lucide-react';
import AuthLayout from '../components/AuthLayout';

// --- MODIFIED: InputField now accepts and displays an 'error' prop ---
const InputField = ({ name, type, placeholder, value, onChange, icon, error }) => {
    const Icon = icon;
    const errorClasses = "ring-red-500 dark:ring-red-500 focus:ring-red-500";
    const defaultClasses = "ring-gray-300 dark:ring-slate-600 focus:ring-teal-500";

    return (
        <div>
            <div className="relative">
                <div className="pointer-events-none absolute inset-y-0 left-0 flex items-center pl-3">
                    <Icon className="h-5 w-5 text-gray-400" aria-hidden="true" />
                </div>
                <input
                    id={name}
                    name={name}
                    type={type}
                    value={value}
                    onChange={onChange}
                    placeholder={placeholder}
                    required
                    className={`block w-full rounded-md border-0 py-3 pl-10 text-gray-900 dark:text-slate-200 bg-white dark:bg-slate-700/50 ring-1 ring-inset placeholder:text-gray-400 focus:ring-2 focus:ring-inset sm:text-sm ${error ? errorClasses : defaultClasses}`}
                />
            </div>
            {error && <p className="mt-1 text-xs text-red-600 dark:text-red-400">{error}</p>}
        </div>
    );
};


export function AuthForm({ type, role }) {
    const [form, setForm] = useState({ username: '', email: '', password: '', confirmPassword: '' });
    // --- MODIFIED: Changed from a single error string to an errors object ---
    const [errors, setErrors] = useState({});
    const [successMessage, setSuccessMessage] = useState('');
    const [loading, setLoading] = useState(false);
    
    const { login } = useAuth();
    const navigate = useNavigate();

    const handleChange = e => {
        setForm({ ...form, [e.target.name]: e.target.value });
        // Clear error for the field being edited
        if (errors[e.target.name]) {
            setErrors({ ...errors, [e.target.name]: null });
        }
    };

    // --- MODIFIED: Complete overhaul of validation logic ---
    const validateForm = () => {
        const newErrors = {};
        
        // Username validation
        if (type === 'register') {
            if (!form.username.trim()) {
                newErrors.username = 'Username is required.';
            } else if (form.username.length < 3) {
                newErrors.username = 'Username must be at least 3 characters long.';
            } else if (!/^[a-zA-Z0-9_]+$/.test(form.username)) {
                newErrors.username = 'Username can only contain letters, numbers, and underscores.';
            }
        }
        
        // Email validation
        if (!form.email) {
            newErrors.email = 'Email is required.';
        } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(form.email)) {
            newErrors.email = 'Please enter a valid email address.';
        }

        // Password validation
        if (!form.password) {
            newErrors.password = 'Password is required.';
        } else if (form.password.length < 8) {
            newErrors.password = 'Password must be at least 8 characters long.';
        } else if (!/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{8,}$/.test(form.password)) {
            newErrors.password = 'Password must contain at least one uppercase letter, one lowercase letter, and one number.';
        }

        // Confirm Password validation
        if (type === 'register') {
            if (!form.confirmPassword) {
                newErrors.confirmPassword = 'Please confirm your password.';
            } else if (form.password && form.password !== form.confirmPassword) {
                newErrors.confirmPassword = 'Passwords do not match.';
            }
        }

        setErrors(newErrors);
        // Returns true if the newErrors object is empty
        return Object.keys(newErrors).length === 0;
    };

    const handleSubmit = async e => {
        e.preventDefault();
        
        if (!validateForm()) {
            return; // Stop submission if validation fails
        }
        
        setSuccessMessage('');
        setLoading(true);

        try {
            const endpoint = type;
            const { confirmPassword, ...formData } = form;
            const payload = { ...formData, role };
            
            const res = await axios.post(`/auth/${endpoint}`, payload);

            if (type === 'register') {
                setSuccessMessage(res.data.message);
            } else {
                login(res.data.user);
                navigate('/');
            }
        } catch (err) {
            // Display server-side errors in a general error box
            setErrors({ form: err.response?.data?.message || 'An unexpected error occurred.' });
        } finally {
            setLoading(false);
        }
    };

    return (
        <AuthLayout>
            <div className="bg-white dark:bg-slate-800 shadow-xl rounded-xl p-8">
                <h2 className="text-2xl mb-2 font-bold text-center text-gray-900 dark:text-slate-100 capitalize">
                    {type === 'register' ? 'Create an Account' : 'Welcome Back'}
                </h2>
                <p className="text-center text-sm text-gray-500 dark:text-slate-400 mb-6">
                    {type === 'login' ? 'Log in to continue to Prism' : `Signing up as an ${role}`}
                </p>

                {!successMessage ? (
                    <form onSubmit={handleSubmit} className="space-y-4">
                        {type === 'register' && (
                            <InputField name="username" type="text" placeholder="Username" value={form.username} onChange={handleChange} icon={User} error={errors.username} />
                        )}
                        <InputField name="email" type="email" placeholder="Email Address" value={form.email} onChange={handleChange} icon={Mail} error={errors.email} />
                        <InputField name="password" type="password" placeholder="Password" value={form.password} onChange={handleChange} icon={KeyRound} error={errors.password} />
                        
                        {type === 'register' && (
                            <InputField name="confirmPassword" type="password" placeholder="Confirm Password" value={form.confirmPassword} onChange={handleChange} icon={KeyRound} error={errors.confirmPassword} />
                        )}
                        
                        {/* --- MODIFIED: For general form errors from the server --- */}
                        {errors.form && (
                            <div className="flex items-center gap-2 text-sm text-red-600 bg-red-50 dark:bg-red-500/10 p-3 rounded-md">
                                <AlertCircle className="h-5 w-5"/>
                                <span>{errors.form}</span>
                            </div>
                        )}
                        
                        <div>
                            <button
                                type="submit"
                                disabled={loading}
                                className="flex w-full justify-center items-center gap-2 rounded-md bg-teal-600 px-3 py-3 text-sm font-semibold text-white shadow-sm hover:bg-teal-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-teal-600 disabled:opacity-50"
                            >
                                {loading && <Loader2 className="h-5 w-5 animate-spin" />}
                                {loading ? 'Processing...' : (type === 'login' ? 'Log In' : 'Create Account')}
                            </button>
                        </div>
                    </form>
                ) : (
                    <div className="text-center">
                        <CheckCircle className="mx-auto h-12 w-12 text-green-500"/>
                        <h3 className="mt-4 text-xl font-semibold text-gray-800 dark:text-slate-200">Success!</h3>
                        <p className="mt-2 text-gray-600 dark:text-slate-400">{successMessage}</p>
                    </div>
                )}
                
                <p className='text-center w-full pt-6 text-sm text-gray-500 dark:text-slate-400'>
                    {type === 'login' ? "Don't have an account?" : "Already have an account?"}
                    <Link to={type === 'login' ? `/${role}/register` : `/${role}/login`} className='font-semibold text-teal-600 dark:text-teal-400 hover:text-teal-500 ml-1'>
                        {type === 'login' ? 'Sign up' : 'Log in'}
                    </Link>
                </p>
            </div>
        </AuthLayout>
    );
}

---

<client\src\pages\BookmarksPage.jsx>

import React, { useState, useEffect } from 'react';
import axios from '../api/axios';
import { Loader2, Bookmark } from 'lucide-react';
import BookmarkCard from '../components/BookmarkCard';
import UserPageLayout from '../components/UserPageLayout';

export default function BookmarksPage() {
    const [activeTab, setActiveTab] = useState('observations');
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    
    const [data, setData] = useState({
        bookmarks: [],
        analysisBookmarks: [],
        movieDetailsMap: {}
    });

    useEffect(() => {
        const fetchBookmarks = async () => {
            try {
                setLoading(true);
                const response = await axios.get('/users/bookmarks');
                setData(response.data);
            } catch (err) {
                setError('Could not load your bookmarks.');
                console.error(err);
            } finally {
                setLoading(false);
            }
        };
        fetchBookmarks();
    }, []);

    const renderContent = () => {
        if (loading) {
            return <div className="flex justify-center items-center h-64"><Loader2 className="animate-spin text-teal-600 dark:text-teal-500" size={48} /></div>;
        }
        if (error) {
            return <p className="text-center text-red-500">{error}</p>;
        }

        const itemsToDisplay = activeTab === 'observations' ? data.bookmarks : data.analysisBookmarks;
        const emptyMessage = activeTab === 'observations' ? "You haven't bookmarked any observations yet." : "You haven't bookmarked any analyses yet.";
        
        return itemsToDisplay.length > 0 ? (
            <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6">
                {itemsToDisplay.map(item => {
                    const movie = data.movieDetailsMap[item.movieId];
                    if (!movie) return null;
                    return <BookmarkCard key={item._id} bookmark={item} movie={movie} />;
                })}
            </div>
        ) : (
            <p className="text-center text-gray-500 dark:text-slate-400 py-12">{emptyMessage}</p>
        );
    };

    return (
        <UserPageLayout title="My Bookmarks" icon={Bookmark}>
            {/* Tab Navigation */}
            <div className="mb-6">
                <nav className="flex space-x-2 sm:space-x-4" aria-label="Tabs">
                    <button onClick={() => setActiveTab('observations')} className={`${activeTab === 'observations' ? 'bg-teal-100 dark:bg-slate-700 text-teal-700 dark:text-slate-100' : 'text-gray-500 dark:text-slate-300 hover:bg-gray-200 dark:hover:bg-slate-800'} px-3 sm:px-4 py-2 font-medium text-sm rounded-md transition-colors`}>
                        Observations
                    </button>
                    <button onClick={() => setActiveTab('analyses')} className={`${activeTab === 'analyses' ? 'bg-teal-100 dark:bg-slate-700 text-teal-700 dark:text-slate-100' : 'text-gray-500 dark:text-slate-300 hover:bg-gray-200 dark:hover:bg-slate-800'} px-3 sm:px-4 py-2 font-medium text-sm rounded-md transition-colors`}>
                        Analyses
                    </button>
                </nav>
            </div>

            {renderContent()}
        </UserPageLayout>
    );
}

---

<client\src\pages\ContributorDashboard.jsx>

import React from 'react';

export default function ContributorDashboard() {
  return (
    <div className="pt-24 max-w-4xl mx-auto px-4 sm:px-6 lg:px-8">
      <div className="pb-5 border-b border-gray-200 dark:border-slate-700">
        <h1 className="text-3xl font-bold text-gray-900 dark:text-slate-100">
          Admin Dashboard
        </h1>
        <p className="mt-2 text-sm text-gray-500 dark:text-slate-400">
          Welcome! Here you can add new movies to our database or manage scenes for existing ones.
        </p>
      </div>

      <div className="mt-8">
        <div className="bg-white dark:bg-slate-800 p-6 rounded-lg shadow-sm border dark:border-slate-700">
          <h2 className="text-lg font-medium text-gray-900 dark:text-slate-200">Manage Movie Scenes</h2>
          <p className="text-gray-600 dark:text-slate-300 mt-1">
            Functionality to search for a movie and manage its scenes will be implemented here.
          </p>
          <button className="mt-4 px-4 py-2 text-sm font-medium text-white bg-teal-600 rounded-md hover:bg-teal-700 transition-colors">
            Find a Movie
          </button>
        </div>
      </div>
    </div>
  );
}


---

<client\src\pages\Home.jsx>

import React, { useState, useEffect, useRef } from 'react';
import { Link } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';
import { ArrowRight, Film, Loader2, ChevronLeft, ChevronRight } from 'lucide-react';
import axios from "../api/axios";
import Header from '../components/Header';

const tmdbImageBaseUrl = 'https://image.tmdb.org/t/p/w500';

const MovieCard = ({ movie }) => (
    <Link to={`/movie/${movie.id}`} className="block group flex-shrink-0 w-40 md:w-48">
        <div className="aspect-[2/3] bg-gray-200 dark:bg-slate-800 rounded-lg overflow-hidden transition-transform transform group-hover:scale-105 group-hover:shadow-xl">
            {movie.poster_path ? (
                <img src={`${tmdbImageBaseUrl}${movie.poster_path}`} alt={movie.title} className="w-full h-full object-cover" />
            ) : (
                <div className="w-full h-full flex items-center justify-center text-gray-400 dark:text-slate-500 bg-gray-100 dark:bg-slate-700">
                    <Film size={48} />
                </div>
            )}
        </div>
        <h3 className="mt-2 text-sm font-medium text-gray-800 dark:text-slate-200 truncate group-hover:text-teal-600 dark:group-hover:text-teal-400">{movie.title}</h3>
    </Link>
);

const MovieCarousel = ({ title, movies, isLoading }) => {
    const scrollRef = useRef(null);
    const [isAtStart, setIsAtStart] = useState(true);
    const [isAtEnd, setIsAtEnd] = useState(false);

    const checkScrollPosition = () => {
        if (scrollRef.current) {
            const { scrollLeft, scrollWidth, clientWidth } = scrollRef.current;
            setIsAtStart(scrollLeft === 0);
            setIsAtEnd(scrollLeft + clientWidth >= scrollWidth - 1); // -1 for precision
        }
    };

    useEffect(() => {
        checkScrollPosition();
        const scroller = scrollRef.current;
        scroller?.addEventListener('scroll', checkScrollPosition);
        return () => scroller?.removeEventListener('scroll', checkScrollPosition);
    }, [movies]);


    const handleScroll = (direction) => {
        if (scrollRef.current) {
            const scrollAmount = scrollRef.current.clientWidth * 0.8;
            scrollRef.current.scrollBy({
                left: direction === 'left' ? -scrollAmount : scrollAmount,
                behavior: 'smooth',
            });
        }
    };

    if (isLoading) {
        return (
            <section className="mb-12">
                <h2 className="text-xl md:text-2xl font-bold text-gray-900 dark:text-slate-100 mb-4">{title}</h2>
                <div className="flex justify-center items-center h-48">
                    <Loader2 className="animate-spin text-teal-600 dark:text-teal-500" size={40} />
                </div>
            </section>
        );
    }

    if (!movies || movies.length === 0) return null;

    return (
        <section className="mb-12 relative">
            <div className="flex items-center justify-between mb-4">
                <h2 className="text-xl md:text-2xl font-bold text-gray-900 dark:text-slate-100">{title}</h2>
                <Link to={`/movies/category/${title.toLowerCase().replace(' ', '-')}`} className="flex items-center gap-1 text-sm font-medium text-teal-600 hover:text-teal-800 dark:text-teal-400 dark:hover:text-teal-300">
                    See All <ArrowRight size={14} />
                </Link>
            </div>
            <div className="relative scrollbar-hide">
                <div ref={scrollRef} className="flex gap-4 md:gap-6 overflow-x-auto pb-4 -mx-6 px-6 scrollbar-hide scroll-smooth">
                    {movies.map(movie => <MovieCard key={movie.id} movie={movie} />)}
                </div>
                {/* Left Arrow */}
                {!isAtStart && (
                    <button onClick={() => handleScroll('left')} className="absolute top-1/2 left-0 -translate-y-1/2 transform bg-white/80 dark:bg-slate-800/80 backdrop-blur-sm h-12 w-12 rounded-full flex items-center justify-center shadow-md hover:bg-white dark:hover:bg-slate-700 transition-opacity z-10 disabled:opacity-0">
                        <ChevronLeft className="text-gray-800 dark:text-slate-200"/>
                    </button>
                )}
                {/* Right Arrow */}
                {!isAtEnd && (
                     <button onClick={() => handleScroll('right')} className="absolute top-1/2 right-0 -translate-y-1/2 transform bg-white/80 dark:bg-slate-800/80 backdrop-blur-sm h-12 w-12 rounded-full flex items-center justify-center shadow-md hover:bg-white dark:hover:bg-slate-700 transition-opacity z-10 disabled:opacity-0">
                        <ChevronRight className="text-gray-800 dark:text-slate-200"/>
                    </button>
                )}
            </div>
        </section>
    );
};


const Hero = () => (
    <div className="relative h-80 md:h-96 bg-gray-900 overflow-hidden">
        <img src="https://images.unsplash.com/photo-1536440136628-849c177e76a1?auto=format&fit=crop&w=1920&q=80" alt="Cinema background" className="absolute inset-0 w-full h-full object-cover opacity-30" />
        <div className="relative h-full flex flex-col items-center justify-center text-center text-white px-4">
            <h1 className="text-4xl md:text-5xl font-extrabold tracking-tight">Deconstruct Your Favorite Films</h1>
            <p className="mt-4 max-w-2xl text-lg text-gray-300">Join a community of film enthusiasts in scene-by-scene analysis and in-depth discussion.</p>
        </div>
    </div>
);

export default function HomePage() {
    const { user, loading: authLoading } = useAuth();
    const [trendingMovies, setTrendingMovies] = useState([]);
    const [topRatedMovies, setTopRatedMovies] = useState([]);
    const [recentlyViewedMovies, setRecentlyViewedMovies] = useState([]);
    const [loading, setLoading] = useState(true);
    const [historyLoading, setHistoryLoading] = useState(true);
    const [error, setError] = useState(null);

    useEffect(() => {
        const fetchPublicMovies = async () => {
            try {
                setLoading(true);
                setError(null);
                const [trendingRes, topRatedRes] = await Promise.all([
                    axios.get('/movies/trending'),
                    axios.get('/movies/top-rated')
                ]);
                setTrendingMovies(trendingRes.data);
                setTopRatedMovies(topRatedRes.data);
            } catch (err) {
                console.error("Failed to fetch movies:", err);
                setError('Could not load film data. Please try again later.');
            } finally {
                setLoading(false);
            }
        };
        fetchPublicMovies();
    }, []);

    useEffect(() => {
        // Fetch recently viewed only if a user is logged in
        if (user) {
            const fetchHistory = async () => {
                try {
                    setHistoryLoading(true);
                    const res = await axios.get('/users/history');
                    setRecentlyViewedMovies(res.data);
                } catch (err) {
                    console.error("Failed to fetch view history:", err);
                } finally {
                    setHistoryLoading(false);
                }
            };
            fetchHistory();
        } else {
            // If user logs out, clear the list
            setRecentlyViewedMovies([]);
            setHistoryLoading(false);
        }
    }, [user]);

    return (
        <div>
            <Header />
            <div className="bg-white dark:bg-slate-800 min-h-screen pt-16 transition-colors">
                <Hero />
                <main className="container mx-auto px-6 py-12">
                    {error ? (
                        <div className="text-center py-10">
                            <p className="text-red-500">{error}</p>
                        </div>
                    ) : (
                      <>
                            <MovieCarousel title="Trending Now" movies={trendingMovies} isLoading={loading} />
                            {!authLoading && user && (
                                <MovieCarousel title="Recently Viewed" movies={recentlyViewedMovies} isLoading={historyLoading} />
                            )}
                            <MovieCarousel title="Top Rated" movies={topRatedMovies} isLoading={loading} />
                        </>
                    )}
                </main>
            </div>
        </div>
    );
}

---

<client\src\pages\MovieObservationsPage.jsx>

import React, { useMemo, useState, useCallback, useEffect } from 'react';
import { useAuth } from '../context/AuthContext';
import axios from '../api/axios';
import { Loader2 } from 'lucide-react';

import { useMovieData } from '../hooks/useMovieData';

import Header from '../components/Header';
import SceneListSidebar from '../components/movie-observations/SceneListSidebar';
import MovieHeader from '../components/movie-observations/MovieHeader';
import ContentTabs from '../components/movie-observations/ContentTabs';
import SceneDetail from '../components/movie-observations/SceneDetail';
import ObservationFeed from '../components/movie-observations/ObservationFeed';
import AnalysisFeed from '../components/movie-observations/AnalysisFeed';

import NewObservationModal from '../components/movie-observations/modals/NewObservationModal';
import UploadAnalysisModal from '../components/movie-observations/modals/UploadAnalysisModal';
import ManageScenesModal from '../components/movie-observations/modals/ManageScenesModal';
import SuggestionModal from '../components/movie-observations/modals/SuggestionModal';

export default function MovieObservationsPage() {
    const { user, loading: authLoading, setUser } = useAuth();

    const observationCategories = [
        "Cinematography",
        "Editing",
        "Sound & Music",
        "Symbolism",
        "Foreshadowing",
        "Character Arc",
        "Dialogue",
        "Pacing",
        "World-Building",
        "Costume & Set Design",
        "Visual Effects",
        "Performance / Acting",
        "Other"
    ];

    const {
        movieId,
        movieDetails,
        scenes, setScenes,
        fetchAllData: refetchAllData,
        observations, setObservations,
        analyses, setAnalyses,
        loading,
        error
    } = useMovieData();
    
    const [showObservationModal, setShowObservationModal] = useState(false);
    const [showAnalysisModal, setShowAnalysisModal] = useState(false);
    const [showManageScenesModal, setShowManageScenesModal] = useState(false);
    const [currentPage, setCurrentPage] = useState("observations");
    const [selectedScene, setSelectedScene] = useState(1);

    // Observation Categories And Sorting
    const [observationSort, setObservationSort] = useState('newest');
    const [activeCategory, setActiveCategory] = useState('All');
    const [analysisSort, setAnalysisSort] = useState('newest');

    const [editingScene, setEditingScene] = useState(null);

    useEffect(() => {
        // If the user is logged in, log this movie to their history
        if (user && movieId) {
            const logView = async () => {
                try {
                    axios.post('/users/history', { movieId });
                } catch (err) {
                    console.error("Failed to log view history:", err);
                }
            };
            logView();
        }
    }, [user, movieId]);

    // Correctly use useEffect to update selectedScene when scenes data loads
    useEffect(() => {
        if (scenes.length > 0 && !scenes.find(s => s.sceneNumber === selectedScene)) {
            setSelectedScene(scenes[0].sceneNumber);
        }
    }, [scenes]);

    // Logic to process observations based on filters/sort
    const processedObservations = useMemo(() => {
        return observations
            .filter(obs => obs.sceneId == selectedScene)
            .filter(obs => {
                if (activeCategory === 'All') return true;
                return obs.categories.includes(activeCategory);
            })
            .sort((a, b) => {
                switch (observationSort) {
                    case 'oldest':
                        return new Date(a.createdAt) - new Date(b.createdAt);
                    case 'mostLiked':
                        return (b.likes?.length || 0) - (a.likes?.length || 0);
                    case 'newest':
                    default:
                        return new Date(b.createdAt) - new Date(a.createdAt);
                }
            });
    }, [observations, selectedScene, activeCategory, observationSort]);

    // Logic to sort analyses 
    const sortedAnalyses = useMemo(() => {
        return [...analyses].sort((a, b) => {
             switch (analysisSort) {
                case 'oldest':
                    return new Date(a.createdAt) - new Date(b.createdAt);
                case 'newest':
                default:
                    return new Date(b.createdAt) - new Date(a.createdAt);
            }
        });
    }, [analyses, analysisSort]);

    // Handlers for adding new content
    const handleObservationAdded = useCallback((newObs) => setObservations(p => [newObs, ...p].sort((a,b) => new Date(b.createdAt) - new Date(a.createdAt))), [setObservations]);
    const handleAnalysisAdded = useCallback((newAnl) => setAnalyses(p => [newAnl, ...p].sort((a,b) => new Date(b.createdAt) - new Date(a.createdAt))), [setAnalyses]);
    const handleSceneAdded = useCallback((newScene) => setScenes(p => [...p, newScene].sort((a,b) => a.sceneNumber - b.sceneNumber)), [setScenes]);

    const [showSuggestionModal, setShowSuggestionModal] = useState(false);
    const [suggestionType, setSuggestionType] = useState('NEW_SCENE');

    const handleSuggestEdit = (type) => {
        setSuggestionType(type);
        setShowSuggestionModal(true);
    };

    // Handlers for likes and bookmarks
    const handleLikeObservation = async (observationId) => {
        if (!user) return alert("Please log in to like observations.");
        try {
            const { data: updatedObservation } = await axios.put(`/observations/${observationId}/like`);
            setObservations(observations.map(obs => obs._id === observationId ? updatedObservation : obs));
        } catch (err) {
            console.error("Failed to like observation:", err);
        }
    };

    const handleBookmarkObservation = async (observationId) => {
        if (!user) return alert("Please log in to bookmark observations.");
        try {
            const { data } = await axios.put(`/observations/${observationId}/bookmark`); 
            setUser({ ...user, bookmarks: data.bookmarks });
        } catch (err) {
            console.error("Failed to bookmark observation:", err);
        }
    };

    const handleLikeAnalysis = async (analysisId) => {
        if (!user) return alert("Please log in to like analyses.");
        try {
            const { data: updatedAnalysis } = await axios.put(`/analyses/${analysisId}/like`);
            setAnalyses(analyses.map(anl => anl._id === analysisId ? updatedAnalysis : anl));
        } catch (err) {
            console.error("Failed to like analysis:", err);
        }
    };

    const handleBookmarkAnalysis = async (analysisId) => {
        if (!user) return alert("Please log in to bookmark analyses.");
        try {
            const { data } = await axios.put(`/analyses/${analysisId}/bookmark`);
            setUser({ ...user, analysisBookmarks: data.analysisBookmarks });
        } catch (err) {
            console.error("Failed to bookmark analysis:", err);
        }
    };

    const handleEditSceneClick = () => {
        setEditingScene(currentSceneData); // Set the current scene as the one to edit
        setShowManageScenesModal(true);
    };

    const handleCloseManageModal = () => {
        setShowManageScenesModal(false);
        setEditingScene(null); // Clear the editing scene when modal closes
    };

    const handleDeleteScene = async () => {
        if (window.confirm(`Are you sure you want to delete Scene ${currentSceneData.sceneNumber}? This will also delete all of its observations.`)) {
            try {
                await axios.delete(`/scenes/${currentSceneData._id}`);
                // Refetch all movie data to ensure the UI is up-to-date
                refetchAllData(); 
            } catch (error) {
                console.error("Failed to delete scene:", error);
                alert("Could not delete the scene. Please try again.");
            }
        }
    };
    
    // Derived State
    const currentSceneData = scenes.find(s => s.sceneNumber === selectedScene) || {};

    // Loading and Error States
    if (loading) {
        return <><Header /><div className="flex justify-center items-center h-screen"><Loader2 className="animate-spin text-teal-600 dark:text-teal-500" size={48} /></div></>;
    }
    if (error) {
        return <><Header /><div className="text-center pt-32"><h2 className="text-2xl font-bold text-red-600">An Error Occurred</h2><p className="text-gray-600 dark:text-slate-400 mt-2">{error}</p></div></>;
    }

    // Main Render
    return (
        <div className="bg-gray-100 dark:bg-slate-900 min-h-screen transition-colors">
            <Header />
            <div className="flex pt-16">
                <SceneListSidebar
                    scenes={scenes}
                    selectedScene={selectedScene}
                    onSelectScene={setSelectedScene}
                    user={user}
                    authLoading={authLoading}
                    onManageScenesClick={() => {
                        setEditingScene(null); // Ensure it's in "create" mode
                        setShowManageScenesModal(true);
                    }}
                    onSuggestNewSceneClick={() => handleSuggestEdit('NEW_SCENE')}
                />

                <main className="flex-1 lg:ml-80 flex flex-col h-[calc(100vh-4rem)]">
                    <div className="flex-1 overflow-y-auto p-4 sm:p-8">
                        <div className="max-w-4xl mx-auto">
                            <MovieHeader details={movieDetails} />

                            <ContentTabs
                                currentPage={currentPage}
                                onSetPage={setCurrentPage}
                                user={user}
                                authLoading={authLoading}
                                scenesExist={scenes.length > 0}
                                onNewObservationClick={() => setShowObservationModal(true)}
                                onUploadAnalysisClick={() => setShowAnalysisModal(true)}
                            />

                            {currentPage === "observations" ? (
                                scenes.length > 0 ? (
                                    <>
                                        <SceneDetail 
                                            sceneData={currentSceneData} 
                                            selectedScene={selectedScene} 
                                            movieDetails={movieDetails}
                                            onSuggestEdit={handleSuggestEdit}
                                            onEditScene={handleEditSceneClick}
                                            onDeleteScene={handleDeleteScene}
                                        />
                                        <ObservationFeed
                                            observations={processedObservations}
                                            user={user}
                                            onLike={handleLikeObservation}
                                            onBookmark={handleBookmarkObservation}
                                            categories={observationCategories}
                                            activeCategory={activeCategory}
                                            setActiveCategory={setActiveCategory}
                                            sort={observationSort}
                                            setSort={setObservationSort}
                                        />
                                    </>
                                ) : (
                                    // If no scenes exist, show this single message
                                    <div className="text-center text-gray-500 dark:text-slate-400 py-12">
                                        <p className="mb-4">No scenes have been added for this movie yet.</p>
                                        {user && (
                                            <button 
                                                onClick={() => handleSuggestEdit('NEW_SCENE')} 
                                                className="px-4 py-2 text-sm font-medium text-white bg-teal-600 rounded-md hover:bg-teal-700"
                                            >
                                                Be the first to add one!
                                            </button>
                                        )}
                                    </div>
                                )
                            ) : (
                                <AnalysisFeed
                                    analyses={sortedAnalyses}
                                    user={user}
                                    onLike={handleLikeAnalysis}
                                    onBookmark={handleBookmarkAnalysis}
                                    sort={analysisSort}
                                    setSort={setAnalysisSort}
                                />
                            )}
                        </div>
                    </div>
                </main>
            </div>
            
            {/* Any logged-in user can access these modals */}
            {user && (
                <>
                    <NewObservationModal 
                        isOpen={showObservationModal} 
                        onClose={() => setShowObservationModal(false)} 
                        movieId={movieId} 
                        selectedScene={selectedScene} 
                        sceneData={currentSceneData} 
                        onObservationAdded={handleObservationAdded}
                    />
                    <UploadAnalysisModal 
                        isOpen={showAnalysisModal} 
                        onClose={() => setShowAnalysisModal(false)} 
                        movieId={movieId} 
                        onAnalysisAdded={handleAnalysisAdded}
                    />
                    <SuggestionModal 
                        isOpen={showSuggestionModal}
                        onClose={() => setShowSuggestionModal(false)}
                        movieId={movieId}
                        suggestionType={suggestionType}
                        sceneToEdit={currentSceneData}
                        scenes={scenes}
                    />
                </>
            )}

            {/* Only Admins can access the direct Scene Management Modal */}
            {user?.role === 'admin' && (
                <ManageScenesModal 
                    isOpen={showManageScenesModal} 
                    onClose={handleCloseManageModal} 
                    movieId={movieId} 
                    scenes={scenes} 
                    onSceneAdded={() => {
                        // This should be a function to refetch all scenes to see updates
                        // For now, we'll just close, but a proper implementation would update the state.
                        console.log("Scene saved, refetching would happen here.");
                    }}
                    isEditing={!!editingScene}
                    sceneToEdit={editingScene}
                />
            )}
        </div>
    );
}


---

<client\src\pages\ObserverLogin.jsx>

import { AuthForm } from './AuthForms'
export default function ObserverLogin() { return <AuthForm type="login" role="observer" /> }


---

<client\src\pages\ObserverRegister.jsx>

import { AuthForm } from './AuthForms'
export default function ObserverRegister() { return <AuthForm type="register" role="observer" /> }


---

<client\src\pages\SearchResultsPage.jsx>

import React, { useState, useEffect } from 'react';
import { useSearchParams } from 'react-router-dom';
import axios from '../api/axios';
import { Loader2 } from 'lucide-react';
import MovieCard from '../components/MovieCard';
import Header from '../components/Header';

export default function SearchResultsPage() {
    const [searchParams] = useSearchParams();
    const query = searchParams.get('query');

    const [results, setResults] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    useEffect(() => {
        if (!query || !query.trim()) {
            setResults([]);
            setLoading(false);
            return;
        }

        const fetchResults = async () => {
            try {
                setLoading(true);
                setError(null);
                const res = await axios.get(`/movies/search?query=${encodeURIComponent(query)}`);
                setResults(res.data);
            } catch (err) {
                console.error("Failed to fetch search results:", err);
                setError('Could not perform search. Please try again later.');
            } finally {
                setLoading(false);
            }
        };

        const searchTimeout = setTimeout(() => {
            fetchResults();
        }, 300);

        return () => clearTimeout(searchTimeout);

    }, [query]);

    const renderContent = () => {
        if (loading) {
            return (
                <div className="flex justify-center items-center h-64">
                    <Loader2 className="animate-spin text-teal-600 dark:text-teal-500" size={48} />
                </div>
            );
        }

        if (error) {
            return <p className="text-center text-red-500">{error}</p>;
        }

        if (results.length === 0) {
            return <p className="text-center text-gray-500 dark:text-slate-400">No results found for "{query}".</p>;
        }

        return (
            <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-x-4 gap-y-8">
                {results.map(movie => (
                    <MovieCard key={movie.id} movie={movie} />
                ))}
            </div>
        );
    };

    return (
        <div>
            <Header/>
            <div className="bg-white dark:bg-slate-800 min-h-screen pt-24 transition-colors">
                <main className="container mx-auto px-6 py-8">
                    {query && (
                        <h1 className="text-2xl md:text-3xl font-bold text-gray-900 dark:text-slate-100 mb-8">
                            Search Results for: <span className="text-teal-600 dark:text-teal-400">"{query}"</span>
                        </h1>
                    )}
                    {renderContent()}
                </main>
            </div>
        </div>
    );
}

---

<client\src\pages\SettingsPage.jsx>

import React, { useState, useRef } from 'react';
import axios from '../api/axios';
import { useAuth } from '../context/AuthContext';
import { useNavigate } from 'react-router-dom';
import { Settings } from 'lucide-react';
import Header from '../components/Header';

// Reusable Card component for the settings page
const SettingsCard = ({ title, description, children }) => (
    <div className="bg-white dark:bg-slate-800 rounded-lg shadow-sm border dark:border-slate-700">
        <div className="p-6 border-b dark:border-slate-700">
            <h3 className="text-lg font-medium text-gray-900 dark:text-slate-100">{title}</h3>
            <p className="mt-1 text-sm text-gray-600 dark:text-slate-400">{description}</p>
        </div>
        <div className="p-6">
            {children}
        </div>
    </div>
);

// Reusable Message component for form feedback
const Message = ({ message }) => {
    if (!message.text) return null;
    const colors = {
        success: 'text-green-600 dark:text-green-400',
        error: 'text-red-600 dark:text-red-500',
        loading: 'text-gray-600 dark:text-slate-400',
    };
    return <p className={`text-sm mt-2 ${colors[message.type]}`}>{message.text}</p>;
};

export default function SettingsPage() {
    const { user, setUser, logout } = useAuth();
    const navigate = useNavigate();
    const avatarFileRef = useRef(null);

    // State for forms
    const [profileData, setProfileData] = useState({ username: user.username, email: user.email });
    const [passwordData, setPasswordData] = useState({ currentPassword: '', newPassword: '' });
    
    // State for avatar
    const [avatarPreview, setAvatarPreview] = useState(null);
    const [avatarFile, setAvatarFile] = useState(null);

    // State for messages
    const [profileMessage, setProfileMessage] = useState({ type: '', text: '' });
    const [passwordMessage, setPasswordMessage] = useState({ type: '', text: '' });
    const [avatarMessage, setAvatarMessage] = useState({ type: '', text: '' });
    
    // State for deleting account
    const [isDeleteModalOpen, setIsDeleteModalOpen] = useState(false);
    const [deleteConfirmText, setDeleteConfirmText] = useState("");

    const handleProfileChange = (e) => setProfileData({ ...profileData, [e.target.name]: e.target.value });
    const handlePasswordChange = (e) => setPasswordData({ ...passwordData, [e.target.name]: e.target.value });
    
    const handleAvatarFileChange = (e) => {
        const file = e.target.files[0];
        if (file) {
            setAvatarFile(file);
            setAvatarPreview(URL.createObjectURL(file));
            setAvatarMessage({ type: '', text: '' });
        }
    };

    const handleAvatarUpload = async () => {
        if (!avatarFile) return;
        setAvatarMessage({ type: 'loading', text: 'Uploading...' });

        const formData = new FormData();
        formData.append('avatar', avatarFile);

        try {
            const { data } = await axios.put('/users/avatar', formData, {
                headers: { 'Content-Type': 'multipart/form-data' },
            });
            setUser({ ...user, avatarUrl: data.avatarUrl }); 
            setAvatarMessage({ type: 'success', text: 'Avatar updated!' });
            setAvatarPreview(null);
            setAvatarFile(null);
        } catch (error) {
             setAvatarMessage({ type: 'error', text: error.response?.data?.message || 'Upload failed.' });
        }
    };

    const handleProfileSubmit = async (e) => {
        e.preventDefault();
        setProfileMessage({ type: 'loading', text: 'Saving...' });
        try {
            await axios.put('/users/profile', profileData);
            setProfileMessage({ type: 'success', text: 'Profile updated successfully!' });
        } catch (error) {
            setProfileMessage({ type: 'error', text: error.response?.data?.message || 'Failed to update profile.' });
        }
    };

    const handlePasswordSubmit = async (e) => {
        e.preventDefault();
        setPasswordMessage({ type: 'loading', text: 'Saving...' });
        try {
            await axios.put('/users/password', passwordData);
            setPasswordMessage({ type: 'success', text: 'Password updated successfully!' });
            setPasswordData({ currentPassword: '', newPassword: '' });
        } catch (error) {
            setPasswordMessage({ type: 'error', text: error.response?.data?.message || 'Failed to update password.' });
        }
    };
    
    const handleDeleteAccount = async () => {
        if (deleteConfirmText !== 'delete my account') return;
        try {
            await axios.delete('/users/profile');
            await logout();
            navigate('/');
        } catch (error) {
            alert('Failed to delete account. Please try again.');
        }
    };
    
    return (
        <div className="bg-gray-100 dark:bg-slate-900 min-h-screen">
            <Header />
            <main className="container mx-auto px-4 sm:px-6 lg:px-8 pt-24 pb-12">
                <div className="max-w-3xl mx-auto">
                    <div className="flex items-center gap-3 mb-6 pb-5 border-b border-gray-200 dark:border-slate-700">
                        <Settings className="text-teal-600 dark:text-teal-400" size={28} />
                        <h1 className="text-2xl font-bold text-gray-900 dark:text-slate-100">Account Settings</h1>
                    </div>
                    
                    <div className="space-y-8">
                        {/* Avatar Settings Card */}
                        <SettingsCard title="Your Avatar" description="Upload a new profile picture.">
                            <div className="flex items-center gap-6">
                                <img 
                                    src={avatarPreview || user.avatarUrl} 
                                    alt="User Avatar"
                                    className="w-20 h-20 rounded-full object-cover bg-gray-200 dark:bg-slate-700"
                                />
                                <div>
                                    <input type="file" accept="image/*" ref={avatarFileRef} onChange={handleAvatarFileChange} className="hidden" />
                                    <button onClick={() => avatarFileRef.current.click()} className="px-4 py-2 border border-gray-300 dark:border-slate-600 rounded-md text-sm font-medium hover:bg-gray-50 dark:hover:bg-slate-700">Change Avatar</button>
                                    {avatarFile && (
                                        <button onClick={handleAvatarUpload} className="ml-3 px-4 py-2 bg-teal-600 text-white rounded-md text-sm font-medium hover:bg-teal-700">Save</button>
                                    )}
                                    <Message message={avatarMessage} />
                                </div>
                            </div>
                        </SettingsCard>

                        {/* Update Profile Form */}
                        <SettingsCard title="Profile Information" description="Update your username and email address.">
                            <form onSubmit={handleProfileSubmit} className="space-y-4">
                                <div>
                                    <label htmlFor="username" className="block text-sm font-medium text-gray-700 dark:text-slate-300">Username</label>
                                    <input type="text" name="username" id="username" value={profileData.username} onChange={handleProfileChange} className="mt-1 w-full p-2 border border-gray-300 dark:border-slate-600 bg-white dark:bg-slate-700 rounded-md"/>
                                </div>
                                <div>
                                    <label htmlFor="email" className="block text-sm font-medium text-gray-700 dark:text-slate-300">Email Address</label>
                                    <input type="email" name="email" id="email" value={profileData.email} onChange={handleProfileChange} className="mt-1 w-full p-2 border border-gray-300 dark:border-slate-600 bg-white dark:bg-slate-700 rounded-md"/>
                                </div>
                                <div className="flex items-center justify-between pt-2">
                                     <Message message={profileMessage} />
                                     <button type="submit" className="px-4 py-2 bg-teal-600 text-white rounded-md text-sm font-medium hover:bg-teal-700">Save Changes</button>
                                </div>
                            </form>
                        </SettingsCard>

                        {/* Change Password Form */}
                        <SettingsCard title="Change Password" description="Choose a new, strong password.">
                            <form onSubmit={handlePasswordSubmit} className="space-y-4">
                                 <div>
                                    <label htmlFor="currentPassword" className="block text-sm font-medium text-gray-700 dark:text-slate-300">Current Password</label>
                                    <input type="password" name="currentPassword" id="currentPassword" value={passwordData.currentPassword} onChange={handlePasswordChange} className="mt-1 w-full p-2 border border-gray-300 dark:border-slate-600 bg-white dark:bg-slate-700 rounded-md"/>
                                </div>
                                <div>
                                    <label htmlFor="newPassword" className="block text-sm font-medium text-gray-700 dark:text-slate-300">New Password</label>
                                    <input type="password" name="newPassword" id="newPassword" value={passwordData.newPassword} onChange={handlePasswordChange} className="mt-1 w-full p-2 border border-gray-300 dark:border-slate-600 bg-white dark:bg-slate-700 rounded-md"/>
                                </div>
                                <div className="flex items-center justify-between pt-2">
                                    <Message message={passwordMessage} />
                                    <button type="submit" className="px-4 py-2 bg-teal-600 text-white rounded-md text-sm font-medium hover:bg-teal-700">Update Password</button>
                                </div>
                            </form>
                        </SettingsCard>

                        {/* Delete Account Section */}
                        <SettingsCard title="Delete Account" description="Permanently delete your account. This action cannot be undone.">
                            <button onClick={() => setIsDeleteModalOpen(true)} className="px-4 py-2 bg-red-600 text-white rounded-md text-sm font-medium hover:bg-red-700">Delete My Account</button>
                        </SettingsCard>
                    </div>
                </div>
            </main>
            
            {/* Delete Confirmation Modal */}
            {isDeleteModalOpen && (
                 <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50 p-4">
                    <div className="bg-white dark:bg-slate-800 rounded-lg shadow-xl p-6 w-full max-w-md">
                        <h3 className="text-lg font-bold text-red-600">Are you absolutely sure?</h3>
                        <p className="mt-2 text-sm text-gray-600 dark:text-slate-300">This will permanently delete your account. Your observations and analyses will be anonymized. To confirm, please type "delete my account" below.</p>
                        <input type="text" value={deleteConfirmText} onChange={(e) => setDeleteConfirmText(e.target.value)} className="mt-4 w-full p-2 border border-gray-300 dark:border-slate-600 bg-white dark:bg-slate-700 rounded-md"/>
                        <div className="mt-6 flex justify-end gap-3">
                            <button onClick={() => setIsDeleteModalOpen(false)} className="px-4 py-2 bg-gray-200 dark:bg-slate-600 rounded-md text-sm">Cancel</button>
                            <button onClick={handleDeleteAccount} disabled={deleteConfirmText !== 'delete my account'} className="px-4 py-2 bg-red-600 text-white rounded-md text-sm disabled:opacity-50">Delete Account</button>
                        </div>
                    </div>
                </div>
            )}
        </div>
    );
}

---

<client\src\pages\VerifyEmailPage.jsx>

// client/src/pages/VerifyEmailPage.jsx
import React, { useState, useEffect } from 'react';
import { useSearchParams, Link } from 'react-router-dom';
import axios from '../api/axios';
import AuthLayout from '../components/AuthLayout';
import { Loader2, CheckCircle, AlertTriangle } from 'lucide-react';

export default function VerifyEmailPage() {
    const [searchParams] = useSearchParams();
    const token = searchParams.get('token');
    
    const [status, setStatus] = useState('verifying'); // 'verifying', 'success', 'error'
    const [message, setMessage] = useState('Verifying your account...');

    useEffect(() => {
        console.log("on verify page");
        

        if (!token) {
            setStatus('error');
            setMessage('No verification token found. Please check the link from your email.');
            return;
        }

        const verify = async () => {
            try {
                const res = await axios.post('/auth/verify-email', { token });
                setStatus('success');
                setMessage(res.data.message);
            } catch (err) {
                setStatus('error');
                setMessage(err.response?.data?.message || 'Verification failed. The link may be invalid or expired.');
            }
        };
        verify();
    }, [token]);

    return (
        <AuthLayout>
            <div className="bg-white dark:bg-slate-800 shadow-xl rounded-xl p-8 text-center">
                {status === 'verifying' && (
                    <>
                        <Loader2 className="mx-auto h-12 w-12 text-teal-500 animate-spin" />
                        <h2 className="mt-4 text-xl font-semibold text-gray-800 dark:text-slate-200">Verifying...</h2>
                    </>
                )}
                {status === 'success' && (
                    <>
                        <CheckCircle className="mx-auto h-12 w-12 text-green-500" />
                        <h2 className="mt-4 text-xl font-semibold text-gray-800 dark:text-slate-200">Verification Successful!</h2>
                        <p className="mt-2 text-gray-600 dark:text-slate-400">{message}</p>
                        <Link to="/observer/login" className="mt-6 inline-block w-full bg-teal-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-teal-700 transition">
                            Proceed to Login
                        </Link>
                    </>
                )}
                {status === 'error' && (
                     <>
                        <AlertTriangle className="mx-auto h-12 w-12 text-red-500" />
                        <h2 className="mt-4 text-xl font-semibold text-gray-800 dark:text-slate-200">Verification Failed</h2>
                        <p className="mt-2 text-gray-600 dark:text-slate-400">{message}</p>
                    </>
                )}
            </div>
        </AuthLayout>
    );
}

---

<client\src\pages\ViewingHistoryPage.jsx>

import React, { useState, useEffect } from 'react';
import axios from '../api/axios';
import { Loader2, History } from 'lucide-react';
import MovieCard from '../components/MovieCard';
import UserPageLayout from '../components/UserPageLayout';

export default function ViewingHistoryPage() {
    const [history, setHistory] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    useEffect(() => {
        const fetchHistory = async () => {
            try {
                setLoading(true);
                const { data } = await axios.get('/users/history');
                setHistory(data);
            } catch (err) {
                setError('Could not load your viewing history.');
                console.error(err);
            } finally {
                setLoading(false);
            }
        };
        fetchHistory();
    }, []);

    const renderContent = () => {
        if (loading) {
            return <div className="flex justify-center items-center h-64"><Loader2 className="animate-spin text-teal-600 dark:text-teal-500" size={48} /></div>;
        }
        if (error) {
            return <p className="text-center text-red-500">{error}</p>;
        }
        return history.length > 0 ? (
            <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-x-4 gap-y-8">
                {history.map(movie => <MovieCard key={movie.id} movie={movie} />)}
            </div>
        ) : (
            <p className="text-center text-gray-500 dark:text-slate-400 py-12">You haven't viewed any movies yet.</p>
        );
    };

    return (
        <UserPageLayout title="Viewing History" icon={History}>
            {renderContent()}
        </UserPageLayout>
    );
}

---

<server\package.json>

{
  "name": "server",
  "version": "1.0.0",
  "type": "module",
  "description": "",
  "main": "src/index.js",
  "scripts": {
    "dev": "nodemon src/index.js",
    "start": "node src/index.js"
  },
  "dependencies": {
    "axios": "^1.11.0",
    "bcryptjs": "^2.4.3",
    "cloudinary": "^1.41.3",
    "cookie-parser": "^1.4.6",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "jsonwebtoken": "^9.0.0",
    "mongodb": "^6.19.0",
    "mongoose": "^7.6.1",
    "multer": "^2.0.2",
    "multer-storage-cloudinary": "^4.0.0",
    "nodemailer": "^7.0.6"
  },
  "devDependencies": {
    "nodemon": "^3.0.1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}


---

<server\src\index.js>

import express from 'express';
import dotenv from 'dotenv';
import cors from 'cors';
import cookieParser from 'cookie-parser';
import connectDB from './config/db.js';
import authRoutes from './routes/authRoutes.js';
import movieRoutes from './routes/movieRoutes.js';
import sceneRoutes from './routes/sceneRoutes.js';
import observationRoutes from './routes/observationRoutes.js';
import analysisRoutes from './routes/analysisRoutes.js';
import userRoutes from './routes/userRoutes.js';
import suggestionRoutes from './routes/suggestionRoutes.js';
import adminRoutes from './routes/adminRoutes.js';

dotenv.config();

const app = express();

app.use(cors({ origin: 'http://localhost:5173', credentials: true }));
app.use(express.json());
app.use(cookieParser());

// --- Routes ---
app.use('/api/auth', authRoutes);
app.use('/api/movies', movieRoutes);
app.use('/api/scenes/', sceneRoutes);
app.use('/api/observations/', observationRoutes);
app.use('/api/analyses/', analysisRoutes);
app.use('/api/users', userRoutes);
app.use('/api/suggestions', suggestionRoutes);
app.use('/api/admin', adminRoutes);

app.get('/', (req, res) => res.send('API is running'));

const PORT = process.env.PORT || 5000;

// --- Start Server Function ---
const startServer = async () => {
  try {
    // Wait for the database connection to be established
    await connectDB();
    
    // Then, start the Express server
    app.listen(PORT, () => console.log(`Server running on port ${PORT}`));
  } catch (error) {
    console.error("Failed to connect to the database", error);
    process.exit(1);
  }
};

// --- Execute the Server Start ---
startServer();

---

<server\src\config\db.js>

import mongoose from 'mongoose'

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI)
    console.log('MongoDB connected')
  } catch (err) {
    console.error(err.message)
    process.exit(1)
  }
}

export default connectDB

---

<server\src\config\mailer.js>

import nodemailer from 'nodemailer';
import dotenv from 'dotenv';

dotenv.config();

// Create a "transporter" object that knows how to send emails
const transporter = nodemailer.createTransport({
    service: 'gmail',
    auth: {
        user: process.env.EMAIL_USER,
        pass: process.env.EMAIL_PASS,
    },
});

/**
 * Sends a verification email to a new user.
 * @param {string} to - The recipient's email address.
 * @param {string} token - The unique verification token.
 */
export const sendVerificationEmail = async (to, token) => {
    const verificationUrl = `http://localhost:5173/verify-email?token=${token}`;

    const mailOptions = {
        from: `"Prism App" <${process.env.EMAIL_USER}>`,
        to: to,
        subject: 'Verify Your Prism Account',
        html: `
            <div style="font-family: Arial, sans-serif; line-height: 1.6;">
                <h2>Welcome to Prism!</h2>
                <p>Thank you for registering. Please click the link below to verify your email address:</p>
                <p>
                    <a href="${verificationUrl}" style="background-color: #0d9488; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px;">
                        Verify My Account
                    </a>
                </p>
                <p>If you did not create an account, please ignore this email.</p>
            </div>
        `,
    };

    try {
        await transporter.sendMail(mailOptions);
        console.log(`Verification email sent to ${to}`);
    } catch (error) {
        console.error(`Error sending email to ${to}:`, error);
        // In a production app, you might want to handle this error more gracefully
    }
};

---

<server\src\controllers\adminController.js>

import Suggestion from '../models/Suggestion.js';
import Scene from '../models/Scene.js';
import User from '../models/User.js';

// @desc    Get all pending suggestions
// @route   GET /api/admin/suggestions
// @access  Private (Admin)
export const getPendingSuggestions = async (req, res) => {
    try {
        const suggestions = await Suggestion.find({ status: 'pending' })
            .populate('suggestedBy', 'username avatarUrl')
            .populate('sceneToEdit')
            .sort({ createdAt: 1 });
        res.json(suggestions);
    } catch (error) {
        res.status(500).json({ message: `Server Error: ${error.message}` });
    }
};

// @desc    Approve a suggestion
// @route   PUT /api/admin/suggestions/:id/approve
// @access  Private (Admin)
export const approveSuggestion = async (req, res) => {
    try {
        const suggestion = await Suggestion.findById(req.params.id);
        if (!suggestion) {
            return res.status(404).json({ message: 'Suggestion not found.' });
        }

        const { suggestionType, payload, sceneToEdit } = suggestion;

        if (suggestionType === 'NEW_SCENE') {
            const newScene = new Scene({
                movieId: suggestion.movieId,
                user: suggestion.suggestedBy,
                ...payload
            });
            await newScene.save();
        } else if (suggestionType === 'EDIT_SCENE') {
            await Scene.findByIdAndUpdate(sceneToEdit, { $set: payload });
        }

        suggestion.status = 'approved';
        await suggestion.save();

        res.json({ message: 'Suggestion approved and applied.' });
    } catch (error) {
        res.status(500).json({ message: `Server Error: ${error.message}` });
    }
};

// @desc    Reject a suggestion
// @route   PUT /api/admin/suggestions/:id/reject
// @access  Private (Admin)
export const rejectSuggestion = async (req, res) => {
    try {
        const suggestion = await Suggestion.findById(req.params.id);
        if (!suggestion) {
            return res.status(404).json({ message: 'Suggestion not found.' });
        }

        suggestion.status = 'rejected';
        await suggestion.save();

        res.json({ message: 'Suggestion rejected.' });
    } catch (error) {
        res.status(500).json({ message: `Server Error: ${error.message}` });
    }
};

export const getAllUsers = async (req, res) => {
    try {
        // Find all users but exclude their passwords from the result
        const users = await User.find({}).select('-password');
        res.json(users);
    } catch (error) {
        res.status(500).json({ message: `Server Error: ${error.message}` });
    }
};

// @desc    Update a user's role
// @route   PUT /api/admin/users/:id/role
// @access  Private (Admin)
export const updateUserRole = async (req, res) => {
    try {
        const { role } = req.body;
        if (!['observer', 'admin'].includes(role)) {
            return res.status(400).json({ message: 'Invalid role specified.' });
        }

        const user = await User.findById(req.params.id);
        if (!user) {
            return res.status(404).json({ message: 'User not found.' });
        }

        // Prevent admin from demoting themselves if they are the last admin
        if (req.user._id.toString() === user._id.toString() && user.role === 'admin' && role === 'observer') {
            const adminCount = await User.countDocuments({ role: 'admin' });
            if (adminCount <= 1) {
                return res.status(400).json({ message: 'Cannot demote the last admin.' });
            }
        }

        user.role = role;
        await user.save();
        res.json({ message: `User role updated to ${role}.` });

    } catch (error) {
        res.status(500).json({ message: `Server Error: ${error.message}` });
    }
};

// @desc    Delete a user
// @route   DELETE /api/admin/users/:id
// @access  Private (Admin)
export const deleteUser = async (req, res) => {
    try {
        const user = await User.findById(req.params.id);
        if (!user) {
            return res.status(404).json({ message: 'User not found.' });
        }
        
        // You cannot delete your own account from the admin panel
        if (req.user._id.toString() === user._id.toString()) {
            return res.status(400).json({ message: 'You cannot delete your own account from here.' });
        }

        await user.deleteOne();
        res.json({ message: 'User deleted successfully.' });

    } catch (error) {
        res.status(500).json({ message: `Server Error: ${error.message}` });
    }
};

---

<server\src\controllers\analysisContoller.js>

import Analysis from '../models/Analysis.js';
import User from '../models/User.js';

// NOTE: File upload logic is mocked for this example.
// In a real app, you'd use a library like multer to handle the file
// upload to a service like S3 or Cloudinary and get a URL.

// @desc    Create a new analysis
// @route   POST /api/analyses
// @access  Private
// ...
export const createAnalysis = async (req, res) => {
  try {
    const { movieId, title, description } = req.body;

    if (!movieId || !title || !description || !req.file) {
      return res.status(400).json({ message: 'Missing required fields or file' });
    }

    const analysis = new Analysis({
      movieId,
      title,
      description,
      // THIS IS THE FIX:
      // The public ID from Cloudinary is available on `req.file.filename`,
      // not `req.file.public_id`. This corrects the validation error.
      filePublicId: req.file.filename, 
      fileSize: req.file.size,
      user: req.user._id,
    });

    const createdAnalysis = await analysis.save();
    await createdAnalysis.populate('user', 'username');
    res.status(201).json(createdAnalysis);
  } catch (error) {
    console.error('ERROR CREATING ANALYSIS:', error); 
    res.status(500).json({ message: `Server Error: ${error.message || 'An unexpected error occurred.'}` });
  }
};
// @desc    Get all analyses for a movie
// @route   GET /api/analyses/:movieId
// @access  Public
export const getAnalysesForMovie = async (req, res) => {
  try {
    const analyses = await Analysis.find({ movieId: req.params.movieId })
      .populate('user', 'username')
      .sort({ createdAt: -1 });

    res.json(analyses);
  } catch (error) {
    res.status(500).json({ message: `Server Error: ${error.message}` });
  }
};

export const likeAnalysis = async (req, res) => {
    try {
        const analysis = await Analysis.findById(req.params.id);

        if (!analysis) {
            return res.status(404).json({ message: 'Analysis not found' });
        }

        const userId = req.user._id.toString();
        const userIndex = analysis.likes.findIndex(id => id.toString() === userId);

        if (userIndex > -1) {
            analysis.likes.splice(userIndex, 1); // Unlike
        } else {
            analysis.likes.push(req.user._id); // Like
        }

        await analysis.save();
        await analysis.populate('user', 'username');
        res.json(analysis);
    } catch (error) {
        res.status(500).json({ message: `Server Error: ${error.message}` });
    }
};

// @desc    Bookmark/Unbookmark an analysis
// @route   PUT /api/analyses/:id/bookmark
// @access  Private
export const toggleAnalysisBookmark = async (req, res) => {
    try {
        const user = await User.findById(req.user._id);
        const analysisId = req.params.id;

        const analysis = await Analysis.findById(analysisId);
        if (!analysis) {
            return res.status(404).json({ message: 'Analysis not found' });
        }

        const isBookmarked = user.analysisBookmarks.includes(analysisId);

        if (isBookmarked) {
            user.analysisBookmarks = user.analysisBookmarks.filter(
                (id) => id.toString() !== analysisId.toString()
            );
        } else {
            user.analysisBookmarks.push(analysisId);
        }

        await user.save();
        res.json({ analysisBookmarks: user.analysisBookmarks });
    } catch (error) {
        res.status(500).json({ message: `Server Error: ${error.message}` });
    }
};

---

<server\src\controllers\authController.js>

import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import crypto from 'crypto';
import User from '../models/User.js';
import { sendVerificationEmail } from '../config/mailer.js';

const generateToken = (res, userId) => {
    const token = jwt.sign({ id: userId }, process.env.JWT_SECRET, {
        expiresIn: process.env.JWT_EXPIRE
    });
    res.cookie('token', token, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
        maxAge: 7 * 24 * 60 * 60 * 1000
    });
};

export const registerUser = async (req, res) => {
    try {
        const { username, email, password, role } = req.body;
        
        // Basic validation
        if (!username || !email || !password || !role) {
            return res.status(400).json({ message: 'Please fill all fields' });
        }

        const userExists = await User.findOne({ email });
        if (userExists) {
            return res.status(400).json({ message: 'A user with this email already exists.' });
        }

        const salt = await bcrypt.genSalt(10);
        const hashedPassword = await bcrypt.hash(password, salt);
        const verificationToken = crypto.randomUUID();

        await User.create({ 
            username, 
            email, 
            password: hashedPassword, 
            role,
            verificationToken 
        });

        // Send the verification email
        await sendVerificationEmail(email, verificationToken);
        
        res.status(201).json({
            message: 'Registration successful! Please check your email to verify your account.'
        });

    } catch (err) {
        console.error("Error in registerUser:", err);
        res.status(500).json({ message: "Server error during registration." });
    }
};

export const loginUser = async (req, res) => {
    try {
        const { email, password, role } = req.body;
        const user = await User.findOne({ email, role });
        
        if (!user || !(await bcrypt.compare(password, user.password))) {
            return res.status(401).json({ message: 'Invalid email or password.' });
        }
        
        if (!user.isVerified) {
            return res.status(403).json({ message: 'Please verify your email before logging in.' });
        }

        generateToken(res, user._id);
        
        // Send user data back, excluding sensitive fields
        res.json({ 
            user: { 
                id: user._id, 
                username: user.username, 
                email: user.email, 
                role: user.role, 
                avatarUrl: user.avatarUrl 
            } 
        });
    } catch (err) {
        console.error("Error in loginUser:", err);
        res.status(500).json({ message: "Server error during login." });
    }
};

export const verifyEmail = async (req, res) => {
    try {
        const { token } = req.body;
        if (!token) {
            return res.status(400).json({ message: 'Verification token is missing.' });
        }

        const user = await User.findOne({ verificationToken: token });
        if (!user) {
            return res.status(400).json({ message: 'Invalid or expired verification token.' });
        }

        user.isVerified = true;
        user.verificationToken = undefined;
        await user.save();

        res.status(200).json({ message: 'Email verified successfully! You can now log in.' });
    } catch (err) {
        console.error("Error in verifyEmail:", err);
        res.status(500).json({ message: 'Server error during email verification.' });
    }
};

export const logoutUser = (req, res) => {
    res.cookie('token', '', { httpOnly: true, expires: new Date(0) });
    res.json({ message: 'Logged out' });
};

export const getMe = async (req, res) => {
    if (!req.user) return res.status(401).json({ message: 'Not authorized' });
    res.json(req.user);
};

---

<server\src\controllers\movieController.js>

import axios from 'axios';
import Movie from '../models/Movie.js';

// --- Simple In-Memory Cache Setup ---
const cache = new Map();
const CACHE_DURATION_MS = 5 * 60 * 1000; // Cache results for 5 minutes

// --- Axios Instance & Interceptor Setup ---
const tmdbApi = axios.create({
  baseURL: 'https://api.themoviedb.org/3',
});

tmdbApi.interceptors.request.use((config) => {
  config.params = config.params || {};
  config.params.api_key = process.env.TMDB_API_KEY;
  return config;
});

const getCachedData = async (cacheKey, fetcher) => {
  const cachedEntry = cache.get(cacheKey);
  if (cachedEntry && (Date.now() - cachedEntry.timestamp < CACHE_DURATION_MS)) {
    return cachedEntry.data;
  }
  const data = await fetcher();
  cache.set(cacheKey, { data, timestamp: Date.now() });
  return data;
};

// --- Controller Functions ---

export const getTrendingMovies = async (req, res) => {
  try {
    const data = await getCachedData('trending', () => 
      tmdbApi.get('/trending/movie/week').then(res => res.data.results)
    );
    res.json(data);
  } catch (err) {
    res.status(500).json({ message: 'Server error while fetching trending movies.' });
  }
};

export const getTopRatedMovies = async (req, res) => {
  try {
    const data = await getCachedData('top_rated', () =>
      tmdbApi.get('/movie/top_rated').then(res => res.data.results)
    );
    res.json(data);
  } catch (err) {
    res.status(500).json({ message: 'Server error while fetching top rated movies.' });
  }
};

export const searchMovies = async (req, res) => {
  const { query } = req.query;
  if (!query) {
    return res.status(400).json({ message: 'Search query is required.' });
  }
  
  const cacheKey = `search_${query}`;
  
  try {
    const data = await getCachedData(cacheKey, () => 
      tmdbApi.get('/search/movie', { params: { query } }).then(res => res.data.results)
    );
    res.json(data);
  } catch (err) {
    res.status(500).json({ message: 'Server error while searching movies.' });
  }
};

export const getMovieDetails = async (req, res) => {
  const { movieId: tmdbId } = req.params;
  const cacheKey = `movie_${tmdbId}`;

  console.log(cacheKey);
  
  try {
    const data = await getCachedData(cacheKey, async () => {

      const tmdbPromise = tmdbApi.get(`/movie/${tmdbId}`);

      const localPromise = Movie.findOne({ tmdbId: tmdbId });
      console.log(localPromise);
      

      const [tmdbResponse, localMovie] = await Promise.all([tmdbPromise, localPromise]);

      const movieDetails = {
        ...tmdbResponse.data, // All the rich data from TMDB
        timestampSource: localMovie ? localMovie.timestampSource : null,
      };

      return movieDetails; // This merged object is cached
    });

    res.json(data);
  } catch (error) {
    if (error.response && error.response.status === 404) {
      return res.status(404).json({ message: 'Movie not found.' });
    }
    console.error("Error in getMovieDetails:", error);
    res.status(500).json({ message: 'Server Error fetching movie details' });
  }
};

---

<server\src\controllers\observationController.js>

import Observation from '../models/Observation.js';
import User from '../models/User.js';

// @desc    Create a new observation
// @route   POST /api/observations
// @access  Private
export const createObservation = async (req, res) => {
  try {
    const { movieId, sceneId, content, timestamp, categories } = req.body;

    if (!movieId || !sceneId || !content || !categories) {
      return res.status(400).json({ message: 'Missing required fields' });
    }

    const observation = new Observation({
      movieId,
      sceneId,
      content,
      timestamp,
      categories,
      user: req.user._id, // from 'protect' middleware
    });

    const createdObservation = await observation.save();
    // Populate user details before sending back
    await createdObservation.populate('user', 'username');
    res.status(201).json(createdObservation);
  } catch (error) {
    res.status(500).json({ message: `Server Error: ${error.message}` });
  }
};

// @desc    Get all observations for a movie
// @route   GET /api/observations/:movieId
// @access  Public
export const getObservationsForMovie = async (req, res) => {
  try {
    const observations = await Observation.find({ movieId: req.params.movieId })
      .populate('user', 'username') // Only get username from user doc
      .sort({ createdAt: -1 }); // Show newest first

    res.json(observations);
  } catch (error) {
    res.status(500).json({ message: `Server Error: ${error.message}` });
  }
};

// @desc    Like/Unlike an observation
// @route   PUT /api/observations/:id/like
// @access  Private
export const likeObservation = async (req, res) => {
    try {
        const observation = await Observation.findById(req.params.id);

        if (!observation) {
            return res.status(404).json({ message: 'Observation not found' });
        }

        // Check if the post has already been liked by this user
        if (observation.likes.includes(req.user._id)) {
            // Unlike it
            observation.likes = observation.likes.filter(
                (userId) => userId.toString() !== req.user._id.toString()
            );
        } else {
            // Like it
            observation.likes.push(req.user._id);
        }

        await observation.save();
        await observation.populate('user', 'username');
        res.json(observation);
    } catch (error) {
        res.status(500).json({ message: `Server Error: ${error.message}` });
    }
};

// @desc    Bookmark/Unbookmark an observation
// @route   PUT /api/observations/:id/bookmark
// @access  Private
export const toggleBookmark = async (req, res) => {
    try {
        const user = await User.findById(req.user._id);
        const observationId = req.params.id;

        // Check if the observation exists to prevent errors
        const observation = await Observation.findById(observationId);
        if (!observation) {
            return res.status(404).json({ message: 'Observation not found' });
        }

        // Check if the observation has already been bookmarked
        const isBookmarked = user.bookmarks.includes(observationId);

        if (isBookmarked) {
            user.bookmarks = user.bookmarks.filter(
                (id) => id.toString() !== observationId.toString()
            );
        } else {
            user.bookmarks.push(observationId);
        }

        await user.save();
        res.json({ bookmarks: user.bookmarks });
    } catch (error) {
        res.status(500).json({ message: `Server Error: ${error.message}` });
    }
};

---

<server\src\controllers\sceneController.js>

import Scene from '../models/Scene.js';
import Movie from '../models/Movie.js';
import Observation from '../models/Observation.js';

export const createScene = async (req, res) => {
    const {
        movieId,
        sceneNumber,
        description,
        startTime,
        endTime,
        timestampSourceName,
        timestampSourceUrl
    } = req.body;

    try {
        if (!req.files || !req.files.startFrame || !req.files.endFrame) {
            return res.status(400).json({ message: 'Start and end frame images are required.' });
        }

        const startFrameUrl = req.files.startFrame[0].path;
        const endFrameUrl = req.files.endFrame[0].path;

        if (timestampSourceName) {
            await Movie.findOneAndUpdate(
                { tmdbId: movieId },
                {
                    $set: {
                        tmdbId: movieId,
                        timestampSource: {
                            name: timestampSourceName,
                            url: timestampSourceUrl || ''
                        }
                    }
                },
                { upsert: true, new: true }
            );
        }

        const newScene = new Scene({
            movieId,
            sceneNumber,
            description,
            startTime,
            endTime,
            startFrameUrl,
            endFrameUrl,
            user: req.user._id,
        });

        const createdScene = await newScene.save();
        res.status(201).json(createdScene);

    } catch (error) {
        if (error.code === 11000) {
            return res.status(400).json({ message: `Scene number ${sceneNumber} already exists for this movie.` });
        }
        res.status(500).json({ message: `Server Error: ${error.message}` });
    }
};

export const getScenesForMovie = async (req, res) => {
    try {
        const scenes = await Scene.find({ movieId: req.params.movieId }).sort({ sceneNumber: 1 });
        res.json(scenes);
    } catch (error) {
        res.status(500).json({ message: `Server Error: ${error.message}` });
    }
};

// @desc    Update an existing scene
// @route   PUT /api/scenes/:id
// @access  Private (Admin)
export const updateScene = async (req, res) => {
    try {
        const scene = await Scene.findById(req.params.id);

        if (!scene) {
            return res.status(404).json({ message: 'Scene not found.' });
        }

        const { description, startTime, endTime } = req.body;
        
        // Update text fields
        scene.description = description || scene.description;
        scene.startTime = startTime || scene.startTime;
        scene.endTime = endTime || scene.endTime;

        // Check for and update new frame images if they were uploaded
        if (req.files) {
            if (req.files.startFrame) {
                scene.startFrameUrl = req.files.startFrame[0].path;
            }
            if (req.files.endFrame) {
                scene.endFrameUrl = req.files.endFrame[0].path;
            }
        }

        const updatedScene = await scene.save();
        res.json(updatedScene);

    } catch (error) {
        res.status(500).json({ message: `Server Error: ${error.message}` });
    }
};

// @desc    Delete a scene
// @route   DELETE /api/scenes/:id
// @access  Private (Admin)
export const deleteScene = async (req, res) => {
    try {
        const scene = await Scene.findById(req.params.id);

        if (!scene) {
            return res.status(404).json({ message: 'Scene not found.' });
        }

        // Before deleting the scene, delete all observations associated with it
        await Observation.deleteMany({ 
            movieId: scene.movieId, 
            sceneId: scene.sceneNumber 
        });
        
        // Now, delete the scene itself
        await scene.deleteOne();

        res.json({ message: 'Scene and associated observations deleted successfully.' });

    } catch (error) {
        res.status(500).json({ message: `Server Error: ${error.message}` });
    }
};

---

<server\src\controllers\suggestionController.js>

import Suggestion from '../models/Suggestion.js';

// @desc    Create a new suggestion for a scene
// @route   POST /api/suggestions
// @access  Private (Observers)
export const createSuggestion = async (req, res) => {
    try {
        const { movieId, suggestionType, sceneToEdit, sceneNumber, description, startTime, endTime, notes } = req.body;

        const payload = {};
        if (description) payload.description = description;
        if (startTime) payload.startTime = startTime;
        if (endTime) payload.endTime = endTime;
        if (sceneNumber) payload.sceneNumber = sceneNumber;
        if (req.files?.startFrame) payload.startFrameUrl = req.files.startFrame[0].path;
        if (req.files?.endFrame) payload.endFrameUrl = req.files.endFrame[0].path;

        if (Object.keys(payload).length === 0) {
            return res.status(400).json({ message: 'No changes were suggested.' });
        }

        const suggestion = new Suggestion({
            movieId,
            suggestionType,
            sceneToEdit: suggestionType === 'EDIT_SCENE' ? sceneToEdit : null,
            suggestedBy: req.user._id,
            payload,
            notes,
        });

        await suggestion.save();
        res.status(201).json({ message: 'Suggestion submitted successfully! It will be reviewed by an admin.' });

    } catch (error) {
        console.error("Error creating suggestion:", error);
        res.status(500).json({ message: 'Server Error: Could not submit suggestion.' });
    }
};

---

<server\src\controllers\userController.js>

// server/src/controllers/userController.js

import User from '../models/User.js';
import axios from 'axios';
import bcrypt from 'bcryptjs';
import Observation from '../models/Observation.js';
import Analysis from '../models/Analysis.js';

const TMDB_API_KEY = process.env.TMDB_API_KEY;

// @desc    Log a movie to the user's view history
// @route   POST /api/users/history
// @access  Private
export const logViewHistory = async (req, res) => {
    try {
        const { movieId } = req.body;
        const user = await User.findById(req.user._id);

        if (!user) {
            return res.status(404).json({ message: 'User not found' });
        }

        user.viewHistory = user.viewHistory.filter(item => item.movieId !== movieId);
        user.viewHistory.unshift({ movieId });

        if (user.viewHistory.length > 20) {
            user.viewHistory = user.viewHistory.slice(0, 20);
        }

        await user.save();
        res.status(200).json({ message: 'View history updated' });

    } catch (error) {
        res.status(500).json({ message: `Server Error: ${error.message}` });
    }
};

// @desc    Get the user's view history with movie details
// @route   GET /api/users/history
// @access  Private
export const getViewHistory = async (req, res) => {
    try {
        const user = await User.findById(req.user._id);

        if (!user || user.viewHistory.length === 0) {
            return res.json([]);
        }

        const movieDetailsPromises = user.viewHistory.map(item =>
            axios.get(`https://api.themoviedb.org/3/movie/${item.movieId}?api_key=${TMDB_API_KEY}&language=en-US`)
        );

        // *** FIX: Use Promise.allSettled to handle potential errors ***
        const results = await Promise.allSettled(movieDetailsPromises);

        const movies = results
            .filter(result => result.status === 'fulfilled') // Keep only successful requests
            .map(result => result.value.data); // Extract the movie data

        res.json(movies);

    } catch (error) {
        console.error("Error in getViewHistory:", error.message);
        res.status(500).json({ message: `Server Error: ${error.message}` });
    }
};

// @desc    Get all of a user's bookmarks
// @route   GET /api/users/bookmarks
// @access  Private
export const getBookmarks = async (req, res) => {
    try {
        const user = await User.findById(req.user._id)
            .populate('bookmarks')
            .populate('analysisBookmarks');

        if (!user) {
            return res.status(404).json({ message: 'User not found' });
        }

        const observationMovieIds = user.bookmarks.map(b => b.movieId);
        const analysisMovieIds = user.analysisBookmarks.map(b => b.movieId);
        const allMovieIds = [...new Set([...observationMovieIds, ...analysisMovieIds])];

        const movieDetailsPromises = allMovieIds.map(id =>
            axios.get(`https://api.themoviedb.org/3/movie/${id}?api_key=${TMDB_API_KEY}&language=en-US`)
        );
        
        // *** FIX: Use Promise.allSettled here as well for robustness ***
        const movieDetailsResults = await Promise.allSettled(movieDetailsPromises);
        
        const movieDetailsMap = movieDetailsResults
            .filter(result => result.status === 'fulfilled')
            .reduce((acc, result) => {
                const movieData = result.value.data;
                acc[movieData.id] = {
                    title: movieData.title,
                    poster_path: movieData.poster_path,
                    release_date: movieData.release_date
                };
                return acc;
            }, {});

        const populatedBookmarks = await Observation.populate(user.bookmarks, { path: 'user', select: 'username' });
        const populatedAnalysisBookmarks = await Analysis.populate(user.analysisBookmarks, { path: 'user', select: 'username' });

        res.json({
            bookmarks: populatedBookmarks.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt)),
            analysisBookmarks: populatedAnalysisBookmarks.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt)),
            movieDetailsMap: movieDetailsMap,
        });
    } catch (error) {
        res.status(500).json({ message: `Server Error: ${error.message}` });
    }
};

// @desc    Update user profile (username, email, avatar)
// @route   PUT /api/users/profile
// @access  Private
export const updateUserProfile = async (req, res) => {
    const { username, email } = req.body;
    const user = await User.findById(req.user._id);

    if (user) {
        user.username = username || user.username;
        user.email = email || user.email;
        const updatedUser = await user.save();
        res.json({
            _id: updatedUser._id,
            username: updatedUser.username,
            email: updatedUser.email,
            role: updatedUser.role,
            avatarUrl: updatedUser.avatarUrl,
        });
    } else {
        res.status(404).json({ message: 'User not found' });
    }
};

// @desc    Update user password
// @route   PUT /api/users/password
// @access  Private
export const updateUserPassword = async (req, res) => {
    const { currentPassword, newPassword } = req.body;
    const user = await User.findById(req.user._id);

    if (user && (await bcrypt.compare(currentPassword, user.password))) {
        if (newPassword && newPassword.length >= 6) {
            user.password = await bcrypt.hash(newPassword, 10);
            await user.save();
            res.json({ message: 'Password updated successfully' });
        } else {
            res.status(400).json({ message: 'New password must be at least 6 characters long.' });
        }
    } else {
        res.status(401).json({ message: 'Invalid current password' });
    }
};

// @desc    Update user avatar
// @route   PUT /api/users/avatar
// @access  Private
export const updateUserAvatar = async (req, res) => {
    try {
        if (!req.file) {
            return res.status(400).json({ message: 'No image file provided.' });
        }
        const user = await User.findById(req.user._id);
        if (!user) {
            return res.status(404).json({ message: 'User not found.' });
        }
        user.avatarUrl = req.file.path;
        await user.save();
        res.json({
            message: 'Avatar updated successfully',
            avatarUrl: user.avatarUrl
        });
    } catch (error) {
        res.status(500).json({ message: `Server Error: ${error.message}` });
    }
};

// @desc    Delete user account
// @route   DELETE /api/users/profile
// @access  Private
export const deleteUserAccount = async (req, res) => {
    try {
        const userId = req.user._id;
        await Observation.updateMany({ user: userId }, { $unset: { user: "" } });
        await Analysis.updateMany({ user: userId }, { $unset: { user: "" } });
        await User.findByIdAndDelete(userId);
        res.cookie('jwt', '', { httpOnly: true, expires: new Date(0) });
        res.json({ message: 'Account deleted successfully' });
    } catch (error) {
        res.status(500).json({ message: `Server Error: ${error.message}` });
    }
};

---

<server\src\middleware\authMiddleware.js>

import jwt from 'jsonwebtoken'
import User from '../models/User.js'

export const protect = async (req, res, next) => {
  try {
    const token = req.cookies.token
    if (!token) return res.status(401).json({ message: 'Not authorized' })

    const decoded = jwt.verify(token, process.env.JWT_SECRET)
    req.user = await User.findById(decoded.id).select('-password')
    next()
  } catch (err) {
    return res.status(401).json({ message: 'Invalid token' })
  }
}


---

<server\src\middleware\uploadMiddleware.js>

import multer from 'multer';
import { v2 as cloudinary } from 'cloudinary';
import { CloudinaryStorage } from 'multer-storage-cloudinary';
import dotenv from 'dotenv';
import path from 'path';

dotenv.config();

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

const storage = new CloudinaryStorage({
  cloudinary: cloudinary,
  params: {
    folder: 'prism_scenes',
    allowed_formats: ['jpeg', 'png', 'jpg'],
  },
});

const upload = multer({ storage: storage });

export const uploadSceneImages = upload.fields([
  { name: 'startFrame', maxCount: 1 },
  { name: 'endFrame', maxCount: 1 },
]);

const analysisStorage = new CloudinaryStorage({
  cloudinary,
  params: async (req, file) => {
    return {
      folder: 'prism_analyses',
      resource_type: 'raw',
      format: 'pdf',
      use_filename: true,
      unique_filename: true,
    };
  },
});

const avatarStorage = new CloudinaryStorage({
  cloudinary: cloudinary,
  params: {
    folder: 'prism_avatars',
    allowed_formats: ['jpeg', 'png', 'jpg', 'gif'],
    // Apply a transformation to create a square, 150x150 avatar
    transformation: [{ width: 150, height: 150, crop: 'fill', gravity: 'face' }],
    // Generate a unique public_id based on the user's ID to prevent duplicates
    public_id: (req, file) => `avatar-${req.user._id}`,
  },
});

const uploadAnalysisPdf = multer({ storage: analysisStorage });

const uploadAvatar = multer({ 
  storage: avatarStorage,
  // Optional: Add file size limit
  limits: { fileSize: 2 * 1024 * 1024 } // 2MB limit
});

export const uploadAvatarFile = uploadAvatar.single('avatar');
export const uploadAnalysisFile = uploadAnalysisPdf.single('analysisFile');

---

<server\src\models\Analysis.js>

import mongoose from 'mongoose';

const analysisSchema = new mongoose.Schema(
  {
    movieId: { type: String, required: true, index: true },
    title: { type: String, required: true, maxlength: 150 },
    description: { type: String, required: true },
    filePublicId: { type: String, required: true },
    fileSize: { type: Number },
    user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
    likes: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }],
    downloads: { type: Number, default: 0 },
  },
  { timestamps: true }
);

export default mongoose.model('Analysis', analysisSchema);


---

<server\src\models\Movie.js>

import mongoose from 'mongoose';

const movieSchema = new mongoose.Schema({
  tmdbId: { 
    type: String, 
    required: true, 
    unique: true, 
    index: true 
  },
  timestampSource: {
    name: { type: String },
    url: { type: String },
  },
}, { timestamps: true });

export default mongoose.model('Movie', movieSchema);

---

<server\src\models\Observation.js>

import mongoose from 'mongoose';

const observationSchema = new mongoose.Schema(
  {
    movieId: { type: String, required: true },
    sceneId: { type: Number, required: true },
    content: { type: String, required: true },
    timestamp: { type: String },
    categories: [{ type: String }],
    user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
    likes: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }],
  },
  { timestamps: true }
);

export default mongoose.model('Observation', observationSchema);


---

<server\src\models\Scene.js>

import mongoose from 'mongoose';

const sceneSchema = new mongoose.Schema(
  {
    movieId: { type: String, required: true, index: true },
    sceneNumber: { type: Number, required: true },
    description: { type: String, required: true },
    startTime: { type: String, required: true },
    endTime: { type: String, required: true },
    startFrameUrl: { type: String, required: true },
    endFrameUrl: { type: String, required: true },
    user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  },
  { timestamps: true }
);

// Ensure a movie can't have duplicate scene numbers
sceneSchema.index({ movieId: 1, sceneNumber: 1 }, { unique: true });

export default mongoose.model('Scene', sceneSchema);

---

<server\src\models\Suggestion.js>

import mongoose from 'mongoose';

const suggestionSchema = new mongoose.Schema({
    movieId: { type: String, required: true, index: true },
    
    // Type of suggestion being made
    suggestionType: { 
        type: String, 
        enum: ['NEW_SCENE', 'EDIT_SCENE'], 
        required: true 
    },
    
    // The user who made the suggestion
    suggestedBy: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
    
    // If editing, this links to the original scene
    sceneToEdit: { type: mongoose.Schema.Types.ObjectId, ref: 'Scene' },

    // The actual data being suggested
    payload: {
        sceneNumber: { type: Number },
        description: { type: String },
        startTime: { type: String },
        endTime: { type: String },
        // We will store temp URLs until approved
        startFrameUrl: { type: String }, 
        endFrameUrl: { type: String }
    },
    
    status: {
        type: String,
        enum: ['pending', 'approved', 'rejected'],
        default: 'pending',
        index: true
    },
    
    // Optional notes from the user
    notes: { type: String } 

}, { timestamps: true });

export default mongoose.model('Suggestion', suggestionSchema);

---

<server\src\models\User.js>

import mongoose from 'mongoose'

const userSchema = new mongoose.Schema(
  {
    username: { type: String, required: true },
    email: { type: String, required: true, unique: true },
    password: { type: String, required: true },
    role: { type: String, enum: ['observer', 'admin'], required: true },
    isVerified: { type: Boolean, default: false },
    verificationToken: { type: String },
    avatarUrl: {
      type: String,
      default: function() {
        return `https://ui-avatars.com/api/?name=${encodeURIComponent(this.username)}&background=random&color=fff`;
      }
    },
    bookmarks: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Observation' }],
    analysisBookmarks: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Analysis' }],
    viewHistory: [
      {
        movieId: { type: String, required: true },
        viewedAt: { type: Date, default: Date.now },
      },
    ],
  },
  { timestamps: true }
)

export default mongoose.model('User', userSchema)

---

<server\src\routes\adminRoutes.js>

import express from 'express';
import { 
    getPendingSuggestions, 
    approveSuggestion, 
    rejectSuggestion,
    getAllUsers,
    updateUserRole,
    deleteUser
} from '../controllers/adminController.js';
import { protect } from '../middleware/authMiddleware.js';

const router = express.Router();

// Middleware to ensure only admins can access these routes
const isAdmin = (req, res, next) => {
    if (req.user && req.user.role === 'admin') {
        next();
    } else {
        res.status(403).json({ message: 'Forbidden: Admin access required.' });
    }
};

router.get('/suggestions', protect, isAdmin, getPendingSuggestions);
router.put('/suggestions/:id/approve', protect, isAdmin, approveSuggestion);
router.put('/suggestions/:id/reject', protect, isAdmin, rejectSuggestion);
router.get('/users', protect, isAdmin, getAllUsers);
router.put('/users/:id/role', protect, isAdmin, updateUserRole);
router.delete('/users/:id', protect, isAdmin, deleteUser);

export default router;

---

<server\src\routes\analysisRoutes.js>

import express from 'express';
import { 
    createAnalysis, 
    getAnalysesForMovie, 
    likeAnalysis,
    toggleAnalysisBookmark
} from '../controllers/analysisContoller.js';
import { protect } from '../middleware/authMiddleware.js';
import { uploadAnalysisFile } from '../middleware/uploadMiddleware.js';

const router = express.Router();

router.route('/')
  .post(protect, uploadAnalysisFile, createAnalysis);

router.route('/:movieId')
  .get(getAnalysesForMovie);

router.route('/:id/like').put(protect, likeAnalysis); 

router.route('/:id/bookmark').put(protect, toggleAnalysisBookmark);

export default router;

---

<server\src\routes\authRoutes.js>

import express from 'express';
import { registerUser, loginUser, logoutUser, getMe, verifyEmail } from '../controllers/authController.js';
import { protect } from '../middleware/authMiddleware.js';

const router = express.Router();

// Simplified routes that the new frontend uses
router.post('/register', registerUser);
router.post('/login', loginUser);
router.post('/logout', logoutUser);
router.get('/me', protect, getMe);

// New route for handling the email verification link
router.post('/verify-email', verifyEmail);

export default router;

---

<server\src\routes\movieRoutes.js>

import express from 'express';
import { 
    getTrendingMovies, 
    getTopRatedMovies, 
    searchMovies,
    getMovieDetails
} from '../controllers/movieController.js';

const router = express.Router();

// @desc   Fetch trending movies for the week
// @route  GET /api/movies/trending
// @access Public
router.get('/trending', getTrendingMovies);

// @desc   Fetch top-rated movies
// @route  GET /api/movies/top-rated
// @access Public
router.get('/top-rated', getTopRatedMovies);

// @desc   Search for movies by a query string
// @route  GET /api/movies/search
// @access Public
router.get('/search', searchMovies);

// @desc   Get details for a single movie by its TMDB ID
// @route  GET /api/movies/:movieId
// @access Public
router.get('/:movieId', getMovieDetails);

export default router;



---

<server\src\routes\observationRoutes.js>

import express from 'express';
import {
  createObservation,
  getObservationsForMovie,
  likeObservation,
  toggleBookmark,
} from '../controllers/observationController.js';
import { protect } from '../middleware/authMiddleware.js';

const router = express.Router();

router.route('/').post(protect, createObservation);
router.route('/:movieId').get(getObservationsForMovie);
router.route('/:id/like').put(protect, likeObservation);
router.route('/:id/bookmark').put(protect, toggleBookmark);

export default router;

---

<server\src\routes\sceneRoutes.js>

import express from 'express';
import { createScene, getScenesForMovie, updateScene, deleteScene } from '../controllers/sceneController.js'; 
import { protect } from '../middleware/authMiddleware.js';
import { uploadSceneImages } from '../middleware/uploadMiddleware.js';  

const router = express.Router();

const isAdmin = (req, res, next) => {
    if (req.user && req.user.role === 'admin') {
        next();
    } else {
        res.status(403).json({ message: 'Forbidden: Admin access required.' });
    }
};

// Admins can create scenes directly, while observers use the suggestion route
router.route('/')
  .post(protect, isAdmin, uploadSceneImages, createScene);

router.route('/:movieId')
  .get(getScenesForMovie);

router.route('/:id')
  .put(protect, isAdmin, uploadSceneImages, updateScene)
  .delete(protect, isAdmin, deleteScene);

export default router;

---

<server\src\routes\suggestionRoutes.js>

import express from 'express';
import { createSuggestion } from '../controllers/suggestionController.js';
import { protect } from '../middleware/authMiddleware.js';
import { uploadSceneImages } from '../middleware/uploadMiddleware.js';

const router = express.Router();

// Observers can only create suggestions
router.route('/').post(protect, uploadSceneImages, createSuggestion);

export default router;

---

<server\src\routes\userRoutes.js>

import express from 'express';
import { logViewHistory, getViewHistory, getBookmarks, updateUserPassword, deleteUserAccount, updateUserProfile, updateUserAvatar } from '../controllers/userController.js';
import { protect } from '../middleware/authMiddleware.js'; // Assuming you have this middleware
import { uploadAvatarFile } from '../middleware/uploadMiddleware.js';

const router = express.Router();

router.route('/history')
  .post(protect, logViewHistory)
  .get(protect, getViewHistory);

router.route('/bookmarks').get(protect, getBookmarks);

router.route('/profile')
    .put(protect, updateUserProfile)
    .delete(protect, deleteUserAccount);

router.route('/password').put(protect, updateUserPassword);

router.route('/avatar').put(protect, uploadAvatarFile, updateUserAvatar);

export default router;

---

